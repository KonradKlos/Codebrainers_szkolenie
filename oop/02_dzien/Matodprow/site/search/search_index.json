{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Konspekt Programowanie funkcyjne - wybrane elementy Funkcje anonimowe Funkcja filtruj\u0105ca filter , aplikuj\u0105ca map i redukuj\u0105ca reduce Generowanie list, s\u0142ownik\u00f3w i zbior\u00f3w Wyra\u017cenia generatorowe Programowanie obiektowe Co to jest obiekt, co jest obiektem w Pythonie Jakie s\u0105 obiekty w Pythonie Klasy, pola, metody Dziedziczenie Programowanie webowe - framework do wyboru","title":"Wst\u0119p"},{"location":"index.html#konspekt","text":"Programowanie funkcyjne - wybrane elementy Funkcje anonimowe Funkcja filtruj\u0105ca filter , aplikuj\u0105ca map i redukuj\u0105ca reduce Generowanie list, s\u0142ownik\u00f3w i zbior\u00f3w Wyra\u017cenia generatorowe Programowanie obiektowe Co to jest obiekt, co jest obiektem w Pythonie Jakie s\u0105 obiekty w Pythonie Klasy, pola, metody Dziedziczenie Programowanie webowe - framework do wyboru","title":"Konspekt"},{"location":"about.html","text":"Code Brainers Code Brainers Grupa entuzjast\u00f3w oprogramowania, kt\u00f3rzy postanowili podzieli\u0107 si\u0119 swoj\u0105 pasj\u0105 i uczy\u0107 osoby chc\u0105ce zacz\u0105\u0107 przygod\u0119 z programowaniem. Wybrali\u015bmy j\u0119zyk Python poniewa\u017c jest wszechstronny, przejrzysty oraz prosty w nauce. Team Nasz zesp\u00f3\u0142 sk\u0142ada si\u0119 z kilku deweloper\u00f3w oraz szkoleniowc\u00f3w wykorzystuj\u0105cych j\u0119zyk Python w codziennej pracy oraz organizator\u00f3w i przedsi\u0119biorc\u00f3w, kt\u00f3rzy przygotowali ca\u0142o\u015b\u0107 spraw niezwi\u0105zanych z programowaniem. Organizatorzy Oskar Meysztowicz Rafa\u0142 Terkalski Instruktorzy Leszek Tarkowski Piotr Arciszewski Klemens Noga Jakub St\u0119pak Piotr Ociepka Jacek Pytel Marcin Klimek Code Brainers Sp. z o.o. ul. Plac Matejki 5/22, 31-157 Krak\u00f3w (+48) 533-746-706 biuro@codebrainers.pl","title":"About"},{"location":"about.html#code-brainers","text":"Code Brainers Grupa entuzjast\u00f3w oprogramowania, kt\u00f3rzy postanowili podzieli\u0107 si\u0119 swoj\u0105 pasj\u0105 i uczy\u0107 osoby chc\u0105ce zacz\u0105\u0107 przygod\u0119 z programowaniem. Wybrali\u015bmy j\u0119zyk Python poniewa\u017c jest wszechstronny, przejrzysty oraz prosty w nauce.","title":"Code Brainers"},{"location":"about.html#team","text":"Nasz zesp\u00f3\u0142 sk\u0142ada si\u0119 z kilku deweloper\u00f3w oraz szkoleniowc\u00f3w wykorzystuj\u0105cych j\u0119zyk Python w codziennej pracy oraz organizator\u00f3w i przedsi\u0119biorc\u00f3w, kt\u00f3rzy przygotowali ca\u0142o\u015b\u0107 spraw niezwi\u0105zanych z programowaniem.","title":"Team"},{"location":"about.html#organizatorzy","text":"Oskar Meysztowicz Rafa\u0142 Terkalski","title":"Organizatorzy"},{"location":"about.html#instruktorzy","text":"Leszek Tarkowski Piotr Arciszewski Klemens Noga Jakub St\u0119pak Piotr Ociepka Jacek Pytel Marcin Klimek Code Brainers Sp. z o.o. ul. Plac Matejki 5/22, 31-157 Krak\u00f3w (+48) 533-746-706 biuro@codebrainers.pl","title":"Instruktorzy"},{"location":"dziedziczenie.html","text":"Dziedziczenie Dziedziczenie umo\u017cliwia tworzenie nowych klas, kt\u00f3re przejmuj\u0105 (dziedzicz\u0105) form\u0119 i funkcjonalno\u015b\u0107 klas bazowych. I tak jak dziedzic maj\u0105tku mo\u017ce nim rozporz\u0105dza\u0107, np. doprowadzi\u0107 do ruiny, tak klasy pochodne (dziedzicz\u0105ce) mog\u0105 rozszerza\u0107 i ulepsza\u0107 funkcjonalno\u015b\u0107 klas przodk\u00f3w. Dziedziczenie definiowane jest za pomoc\u0105 sk\u0142adni: class KlasaBazowa : pass class KlasaPochodna ( KlasaBazowa ): pass Przyk\u0142ad (na razie bez rozszerzania klasy bazowej KontoBankowe ): from bank import KontoBankowe class KontoDebetowe ( KontoBankowe ): pass Zadanie 1 Sprawd\u017a czy ca\u0142y interfejs klasy bazowej KontoBankowe znajduje si\u0119 i dzia\u0142a w instancji klasy pochodnej KontoDebetowe . Rozszerzenie zachowania klasy KontoBankowe : class KontoDebetowe ( KontoBankowe ): def __init__ ( self , nazwa , stan = 0 , limit = 0 ): KontoBankowe . __init__ ( self , nazwa , stan ) self . limit = limit def wyplac ( self , ilosc ): \"\"\"Je\u017celi stan konta po operacji przekroczy\u0142by limit, przerwij.\"\"\" if ( self . stan - ilosc ) < ( - self . limit ): print ( \"Brak srodkow na koncie\" ) else : KontoBankowe . wyplac ( self , ilosc ) Zadanie 2 Przetestuj teraz dzia\u0142anie klasy KontoDebetowe . Super Aby wywo\u0142a\u0107 metod\u0119 klasy bazowej, zamiast wpisywa\u0107 d\u0142ugie wyra\u017cenie NazwaKlasyBazowej mo\u017cna u\u017cy\u0107 metody super() zwracaj\u0105cej klas\u0119 rodzica. Jest to szczeg\u00f3lnie przydatne je\u015bli zmienimy nazw\u0119 klasy bazowej, nie trzeba b\u0119dzie wtedy wprowadza\u0107 zmian w klasach pochodnych. Przyk\u0142ad: # bylo: def __init__ ( self , nazwa , stan = 0 , limit = 0 ): KontoBankowe . __init__ ( self , nazwa , stan ) self . limit = limit # jest: def __init__ ( self , nazwa , stan = 0 , limit = 0 ): super () . __init__ ( self , nazwa , stan ) self . limit = limit Zadanie domowe Stw\u00f3rz klas\u0119 bazow\u0105 dla figur geometrycznych: import math class Figura : def obwod ( self ): \"\"\"Obliczanie obwodu.\"\"\" raise NotImplementedError def pole ( self ): \"\"\"Obliczanie pola powierzchni.\"\"\" raise NotImplementedError Nast\u0119pnie zaimplementuj klasy pochodne dla nast\u0119puj\u0105cych figur: ko\u0142o tr\u00f3jk\u0105t r\u00f3wnoboczny prostok\u0105t kwadrat r\u00f3wnoleg\u0142obok trapez prostok\u0105tny Pami\u0119taj o zachowaniu odpowiedniej hierarchii (dziedziczenia) oraz inicjalizacji atrybut\u00f3w (np. wysoko\u015bci, promienia czy d\u0142ugo\u015bci boku) w metodzie __init__ . Wielokrotne dziedziczenie Troch\u0119 jak w prawdziwym \u017cyciu, klasa pochodna mo\u017ce mie\u0107 wi\u0119cej ni\u017c jednego rodzica i od ka\u017cdego rodzica zbiera\u0107 atrybuty i metody. Przyk\u0142ad klasy z dwoma rodzicami: class A : \"\"\"Rodzic pierwszy\"\"\" def __init__ ( self ): super () . __init__ () self . a = \"A\" def fa ( self ): print ( \"a:\" , self . a ) class B : \"\"\"Rodzic drugi\"\"\" def __init__ ( self ): super () . __init__ () self . b = \"B\" def fb ( self ): print ( \"b:\" , self . b ) class Pochodna ( B , A ): \"\"\"Dziecko\"\"\" def __init__ ( self ): super () . __init__ () Dzia\u0142anie: >>> d = Pochodna () >>> d . a 'A' >>> d . b 'B' >>> d . fa () a : A >>> d . fb () b : B Jak wida\u0107 klasa Pochodna zawiera pola i metody od ka\u017cdego z rodzic\u00f3w. Zadanie 3 W klasach A i B zmie\u0144 nazwy metod fa() i fb() na f() . Sprawd\u017a jak zachowa si\u0119 teraz wywo\u0142anie d.f() , gdzie d jest instancj\u0105 klasy pochodnej. Jak na to zachowanie wp\u0142ywa zmiana kolejno\u015bci rodzic\u00f3w przy definicji klasy pochodnej class Pochodna(tutaj_kolejnosc) ?","title":"Dziedziczenie"},{"location":"dziedziczenie.html#dziedziczenie","text":"Dziedziczenie umo\u017cliwia tworzenie nowych klas, kt\u00f3re przejmuj\u0105 (dziedzicz\u0105) form\u0119 i funkcjonalno\u015b\u0107 klas bazowych. I tak jak dziedzic maj\u0105tku mo\u017ce nim rozporz\u0105dza\u0107, np. doprowadzi\u0107 do ruiny, tak klasy pochodne (dziedzicz\u0105ce) mog\u0105 rozszerza\u0107 i ulepsza\u0107 funkcjonalno\u015b\u0107 klas przodk\u00f3w. Dziedziczenie definiowane jest za pomoc\u0105 sk\u0142adni: class KlasaBazowa : pass class KlasaPochodna ( KlasaBazowa ): pass Przyk\u0142ad (na razie bez rozszerzania klasy bazowej KontoBankowe ): from bank import KontoBankowe class KontoDebetowe ( KontoBankowe ): pass Zadanie 1 Sprawd\u017a czy ca\u0142y interfejs klasy bazowej KontoBankowe znajduje si\u0119 i dzia\u0142a w instancji klasy pochodnej KontoDebetowe . Rozszerzenie zachowania klasy KontoBankowe : class KontoDebetowe ( KontoBankowe ): def __init__ ( self , nazwa , stan = 0 , limit = 0 ): KontoBankowe . __init__ ( self , nazwa , stan ) self . limit = limit def wyplac ( self , ilosc ): \"\"\"Je\u017celi stan konta po operacji przekroczy\u0142by limit, przerwij.\"\"\" if ( self . stan - ilosc ) < ( - self . limit ): print ( \"Brak srodkow na koncie\" ) else : KontoBankowe . wyplac ( self , ilosc ) Zadanie 2 Przetestuj teraz dzia\u0142anie klasy KontoDebetowe .","title":"Dziedziczenie"},{"location":"dziedziczenie.html#super","text":"Aby wywo\u0142a\u0107 metod\u0119 klasy bazowej, zamiast wpisywa\u0107 d\u0142ugie wyra\u017cenie NazwaKlasyBazowej mo\u017cna u\u017cy\u0107 metody super() zwracaj\u0105cej klas\u0119 rodzica. Jest to szczeg\u00f3lnie przydatne je\u015bli zmienimy nazw\u0119 klasy bazowej, nie trzeba b\u0119dzie wtedy wprowadza\u0107 zmian w klasach pochodnych. Przyk\u0142ad: # bylo: def __init__ ( self , nazwa , stan = 0 , limit = 0 ): KontoBankowe . __init__ ( self , nazwa , stan ) self . limit = limit # jest: def __init__ ( self , nazwa , stan = 0 , limit = 0 ): super () . __init__ ( self , nazwa , stan ) self . limit = limit","title":"Super"},{"location":"dziedziczenie.html#zadanie-domowe","text":"Stw\u00f3rz klas\u0119 bazow\u0105 dla figur geometrycznych: import math class Figura : def obwod ( self ): \"\"\"Obliczanie obwodu.\"\"\" raise NotImplementedError def pole ( self ): \"\"\"Obliczanie pola powierzchni.\"\"\" raise NotImplementedError Nast\u0119pnie zaimplementuj klasy pochodne dla nast\u0119puj\u0105cych figur: ko\u0142o tr\u00f3jk\u0105t r\u00f3wnoboczny prostok\u0105t kwadrat r\u00f3wnoleg\u0142obok trapez prostok\u0105tny Pami\u0119taj o zachowaniu odpowiedniej hierarchii (dziedziczenia) oraz inicjalizacji atrybut\u00f3w (np. wysoko\u015bci, promienia czy d\u0142ugo\u015bci boku) w metodzie __init__ .","title":"Zadanie domowe"},{"location":"dziedziczenie.html#wielokrotne-dziedziczenie","text":"Troch\u0119 jak w prawdziwym \u017cyciu, klasa pochodna mo\u017ce mie\u0107 wi\u0119cej ni\u017c jednego rodzica i od ka\u017cdego rodzica zbiera\u0107 atrybuty i metody. Przyk\u0142ad klasy z dwoma rodzicami: class A : \"\"\"Rodzic pierwszy\"\"\" def __init__ ( self ): super () . __init__ () self . a = \"A\" def fa ( self ): print ( \"a:\" , self . a ) class B : \"\"\"Rodzic drugi\"\"\" def __init__ ( self ): super () . __init__ () self . b = \"B\" def fb ( self ): print ( \"b:\" , self . b ) class Pochodna ( B , A ): \"\"\"Dziecko\"\"\" def __init__ ( self ): super () . __init__ () Dzia\u0142anie: >>> d = Pochodna () >>> d . a 'A' >>> d . b 'B' >>> d . fa () a : A >>> d . fb () b : B Jak wida\u0107 klasa Pochodna zawiera pola i metody od ka\u017cdego z rodzic\u00f3w. Zadanie 3 W klasach A i B zmie\u0144 nazwy metod fa() i fb() na f() . Sprawd\u017a jak zachowa si\u0119 teraz wywo\u0142anie d.f() , gdzie d jest instancj\u0105 klasy pochodnej. Jak na to zachowanie wp\u0142ywa zmiana kolejno\u015bci rodzic\u00f3w przy definicji klasy pochodnej class Pochodna(tutaj_kolejnosc) ?","title":"Wielokrotne dziedziczenie"},{"location":"iteratory.html","text":"Iteratory Obiekty iterowalne posiadaj\u0105 metod\u0119 __iter__ zwracaj\u0105c\u0105 obiekt iteratora Iterator posiada metod\u0119 __next()__ , kt\u00f3ra zwraca kolejny element z iterowanej sekwencji Je\u015bli iteracja dobieg\u0142a ko\u0144ca (brak kolejnych element\u00f3w) zg\u0142aszany jest wyj\u0105tek StopIteration Iterator jest zwracany przez funkcj\u0119 iter() >>> s = 'ab' >>> it = iter ( s ) >>> it . __next__ () 'a' >>> it . __next__ () 'b' >>> it . __next__ () Traceback ( most recent call last ): StopIteration Przyk\u0142ad:: class Fibs : def __init__ ( self , limit ): self . a = 0 self . b = 1 self . limit = limit def __next__ ( self ): self . a , self . b = self . b , self . a + self . b if self . a > self . limit : raise StopIteration return self . a def __iter__ ( self ): return self :: >>> list ( Fibs ( 100 )) [ 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ] Generatory Generatory s\u0105 iteratorami definiowanymi przy pomocy sk\u0142adni normalnej funkcji. Instrukcja yield zwraca kolejn\u0105 warto\u015b\u0107 z funkcji generatora. :: def reverse ( data ): for index in range ( len ( data ) - 1 , - 1 , - 1 ): yield data [ index ] :: >>> for char in reverse ( 'golf' ): ... print ( char ) f l o g","title":"Iteratory"},{"location":"iteratory.html#iteratory","text":"Obiekty iterowalne posiadaj\u0105 metod\u0119 __iter__ zwracaj\u0105c\u0105 obiekt iteratora Iterator posiada metod\u0119 __next()__ , kt\u00f3ra zwraca kolejny element z iterowanej sekwencji Je\u015bli iteracja dobieg\u0142a ko\u0144ca (brak kolejnych element\u00f3w) zg\u0142aszany jest wyj\u0105tek StopIteration Iterator jest zwracany przez funkcj\u0119 iter() >>> s = 'ab' >>> it = iter ( s ) >>> it . __next__ () 'a' >>> it . __next__ () 'b' >>> it . __next__ () Traceback ( most recent call last ): StopIteration Przyk\u0142ad:: class Fibs : def __init__ ( self , limit ): self . a = 0 self . b = 1 self . limit = limit def __next__ ( self ): self . a , self . b = self . b , self . a + self . b if self . a > self . limit : raise StopIteration return self . a def __iter__ ( self ): return self :: >>> list ( Fibs ( 100 )) [ 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ]","title":"Iteratory"},{"location":"iteratory.html#generatory","text":"Generatory s\u0105 iteratorami definiowanymi przy pomocy sk\u0142adni normalnej funkcji. Instrukcja yield zwraca kolejn\u0105 warto\u015b\u0107 z funkcji generatora. :: def reverse ( data ): for index in range ( len ( data ) - 1 , - 1 , - 1 ): yield data [ index ] :: >>> for char in reverse ( 'golf' ): ... print ( char ) f l o g","title":"Generatory"},{"location":"klasy.html","text":"Klasy Klasy s\u0105 zbiorami atrybut\u00f3w oraz metod. Jako idea, klasy rozpowszechnione s\u0105 w praktycznie wszystkich j\u0119zykach programowania. Umo\u017cliwiaj\u0105 one: Tworzenie nowych typ\u00f3w danych definiowanych przez u\u017cytkownika. Rozszerzanie mo\u017cliwo\u015bci istniej\u0105cych typ\u00f3w danych. Przyk\u0142ad: tworzysz aplikacj\u0119 do gier karcianych. Potrzebujesz struktury danych, kt\u00f3ra fajnie b\u0119dzie reprezentowa\u0142a pojedyncz\u0105 kart\u0119 z talii. Zadanie 1 Jakie atrybuty powinna mie\u0107 twoja klasa kart ? Przyk\u0142ad: projektujesz aplikacj\u0119 naukow\u0105 i potrzebujesz reprezentowa\u0107 wektory , bo wiesz, \u017ce b\u0119dziesz na nich operowa\u0142. Implementujesz zatem klas\u0119 Vector , kt\u00f3ra b\u0119dzie zachowywa\u0142a si\u0119 tak, jak wektory w j\u0119zyku matematyki. Zadanie 2 Sprawd\u017a definicj\u0119 wektora . Jakie operacje algebraiczne klasa Vector b\u0119dzie musia\u0142a obs\u0142ugiwa\u0107? Sk\u0142adnia klasy, s\u0142owniczek Podstawowa sk\u0142adnia \"pustej\" klasy zosta\u0142a zaprezentowana poni\u017cej: class NazwaKlasy : pass Klasa sama w sobie nic nie robi, dopiero nale\u017cy utworzy\u0107 jej obiekt (instancj\u0119) i na niej operowa\u0107: obiekt = NazwaKlasy () instancja = NazwaKlasy () Sk\u0142adnia metody class NazwaKlasy : def nazwa_metody ( self , argument1 , argument2 ): print ( argument1 ) print ( argument2 ) obiekt = NazwaKlasy () obiekt . nazwa_metody ( \"arg1\" , \"arg2\" ) Na co zwr\u00f3ci\u0107 uwag\u0119: nazwy klas stosuj\u0105 Pisowni\u0119Wielb\u0142\u0105dzi\u0105 nazwy metod stosuj\u0105 pisowni\u0119_z_podkre\u015bleniami pierwszym argumentem metody jest zawsze self ; odnosi si\u0119 on do u\u017cywanej instancji klasy i jest domniemywany - nie musimy go podawa\u0107 przy wywo\u0142ywaniu danej metody. Sk\u0142adnia atrybut\u00f3w Wariant 1: class NazwaKlasy : atrybut_pierwszy = \"Warto\u015b\u0107\" atrybut_drugi = 123.0 Wariant 2 (atrybuty nadawane przy tworzeniu obiektu klasy): class NazwaKlasy : def __init__ ( self , trzeci ): self . atrybut_pierwszy = \"Warto\u015b\u0107\" self . atrybut_drugi = 123.0 self . atrybut_trzeci = trzeci Uwaga Metoda __init__ jest uruchamiana przez Pythona w momencie tworzenia instancji klasy, np: instancja = NazwaKlasy ( \"trzeci\" ) print ( instancja . atrybut_pierwszy ) print ( instancja . atrybut_drugi ) print ( instancja . atrybut_trzeci ) Zadanie 3 Zaimplementuj dwie klasy, Product1 oraz Product2 . Niech pierwsza z nich wykorzysta wariant 1 do stworzenia atrybut\u00f3w name i price , a druga niech wykorzysta wariant 2 do stworzenia takich samych atrybut\u00f3w. Zadanie 4 Istniej\u0105ce klasy Product1 i Product2 rozszerz o metod\u0119 details() , kt\u00f3ra wypisze na ekranie nazw\u0119 produktu i jego cen\u0119. Przyk\u0142ad klasy - konto bankowe Dla pe\u0142nego przyk\u0142adu projektowania i implementowania klasy, spr\u00f3bujmy pomy\u015ble\u0107, jak chcieliby\u015bmy zaimplementowa\u0107 konto bankowe jako klas\u0119. W podstawowej wersji potrzebujemy zna\u0107: nazwisko w\u0142a\u015bciciela konta, stan konta. W podstawowej wersji potrzebujemy te\u017c wykonywa\u0107 nast\u0119puj\u0105ce operacje: do\u0142adowanie konta (wp\u0142ata), wyp\u0142ata. W nieco bardziej zaawansowanej wersji mo\u017cemy chcie\u0107 np. zna\u0107 numer konta i m\u00f3c wykonywa\u0107 przelewy na inne konta. class KontoBankowe : def __init__ ( self , nazwa , stan = 0 ): self . nazwa = nazwa self . stan = stan def info ( self ): print ( \"nazwa:\" , self . nazwa ) print ( \"stan:\" , self . stan ) def wyplac ( self , ilosc ): self . stan -= ilosc def wplac ( self , ilosc ): self . stan += ilosc Przyk\u0142ad u\u017cycia: >>> from bank import KontoBankowe >>> jk = KontoBankowe ( \"Jan Kowalski\" , 1000 ) >>> jk . info () nazwa : Jan Kowalski stan : 1000 >>> jk . wplac ( 2000 ) >>> jk . wyplac ( 2500 ) >>> jk . info () nazwa : Jan Kowalski stan : 500 >>> jk . stan = 0 # Dost\u0119p do sk\u0142adowej `stan` >>> jk . info () nazwa : Jan Kowalski stan : 0 Zadanie 5 Wykorzystuj\u0105c implementacj\u0119 konta bankowego, zaimplementuj w nim metod\u0119 przelew() , kt\u00f3ra jako argument pierwszy bierze konto docelowe, a jako argument drugi bierze warto\u015b\u0107 przelewu. Przetestuj dzia\u0142anie klasy KontoBankowe .","title":"Klasy"},{"location":"klasy.html#klasy","text":"Klasy s\u0105 zbiorami atrybut\u00f3w oraz metod. Jako idea, klasy rozpowszechnione s\u0105 w praktycznie wszystkich j\u0119zykach programowania. Umo\u017cliwiaj\u0105 one: Tworzenie nowych typ\u00f3w danych definiowanych przez u\u017cytkownika. Rozszerzanie mo\u017cliwo\u015bci istniej\u0105cych typ\u00f3w danych. Przyk\u0142ad: tworzysz aplikacj\u0119 do gier karcianych. Potrzebujesz struktury danych, kt\u00f3ra fajnie b\u0119dzie reprezentowa\u0142a pojedyncz\u0105 kart\u0119 z talii. Zadanie 1 Jakie atrybuty powinna mie\u0107 twoja klasa kart ? Przyk\u0142ad: projektujesz aplikacj\u0119 naukow\u0105 i potrzebujesz reprezentowa\u0107 wektory , bo wiesz, \u017ce b\u0119dziesz na nich operowa\u0142. Implementujesz zatem klas\u0119 Vector , kt\u00f3ra b\u0119dzie zachowywa\u0142a si\u0119 tak, jak wektory w j\u0119zyku matematyki. Zadanie 2 Sprawd\u017a definicj\u0119 wektora . Jakie operacje algebraiczne klasa Vector b\u0119dzie musia\u0142a obs\u0142ugiwa\u0107?","title":"Klasy"},{"location":"klasy.html#skadnia-klasy-sowniczek","text":"Podstawowa sk\u0142adnia \"pustej\" klasy zosta\u0142a zaprezentowana poni\u017cej: class NazwaKlasy : pass Klasa sama w sobie nic nie robi, dopiero nale\u017cy utworzy\u0107 jej obiekt (instancj\u0119) i na niej operowa\u0107: obiekt = NazwaKlasy () instancja = NazwaKlasy ()","title":"Sk\u0142adnia klasy, s\u0142owniczek"},{"location":"klasy.html#skadnia-metody","text":"class NazwaKlasy : def nazwa_metody ( self , argument1 , argument2 ): print ( argument1 ) print ( argument2 ) obiekt = NazwaKlasy () obiekt . nazwa_metody ( \"arg1\" , \"arg2\" ) Na co zwr\u00f3ci\u0107 uwag\u0119: nazwy klas stosuj\u0105 Pisowni\u0119Wielb\u0142\u0105dzi\u0105 nazwy metod stosuj\u0105 pisowni\u0119_z_podkre\u015bleniami pierwszym argumentem metody jest zawsze self ; odnosi si\u0119 on do u\u017cywanej instancji klasy i jest domniemywany - nie musimy go podawa\u0107 przy wywo\u0142ywaniu danej metody.","title":"Sk\u0142adnia metody"},{"location":"klasy.html#skadnia-atrybutow","text":"Wariant 1: class NazwaKlasy : atrybut_pierwszy = \"Warto\u015b\u0107\" atrybut_drugi = 123.0 Wariant 2 (atrybuty nadawane przy tworzeniu obiektu klasy): class NazwaKlasy : def __init__ ( self , trzeci ): self . atrybut_pierwszy = \"Warto\u015b\u0107\" self . atrybut_drugi = 123.0 self . atrybut_trzeci = trzeci Uwaga Metoda __init__ jest uruchamiana przez Pythona w momencie tworzenia instancji klasy, np: instancja = NazwaKlasy ( \"trzeci\" ) print ( instancja . atrybut_pierwszy ) print ( instancja . atrybut_drugi ) print ( instancja . atrybut_trzeci ) Zadanie 3 Zaimplementuj dwie klasy, Product1 oraz Product2 . Niech pierwsza z nich wykorzysta wariant 1 do stworzenia atrybut\u00f3w name i price , a druga niech wykorzysta wariant 2 do stworzenia takich samych atrybut\u00f3w. Zadanie 4 Istniej\u0105ce klasy Product1 i Product2 rozszerz o metod\u0119 details() , kt\u00f3ra wypisze na ekranie nazw\u0119 produktu i jego cen\u0119.","title":"Sk\u0142adnia atrybut\u00f3w"},{"location":"klasy.html#przykad-klasy-konto-bankowe","text":"Dla pe\u0142nego przyk\u0142adu projektowania i implementowania klasy, spr\u00f3bujmy pomy\u015ble\u0107, jak chcieliby\u015bmy zaimplementowa\u0107 konto bankowe jako klas\u0119. W podstawowej wersji potrzebujemy zna\u0107: nazwisko w\u0142a\u015bciciela konta, stan konta. W podstawowej wersji potrzebujemy te\u017c wykonywa\u0107 nast\u0119puj\u0105ce operacje: do\u0142adowanie konta (wp\u0142ata), wyp\u0142ata. W nieco bardziej zaawansowanej wersji mo\u017cemy chcie\u0107 np. zna\u0107 numer konta i m\u00f3c wykonywa\u0107 przelewy na inne konta. class KontoBankowe : def __init__ ( self , nazwa , stan = 0 ): self . nazwa = nazwa self . stan = stan def info ( self ): print ( \"nazwa:\" , self . nazwa ) print ( \"stan:\" , self . stan ) def wyplac ( self , ilosc ): self . stan -= ilosc def wplac ( self , ilosc ): self . stan += ilosc Przyk\u0142ad u\u017cycia: >>> from bank import KontoBankowe >>> jk = KontoBankowe ( \"Jan Kowalski\" , 1000 ) >>> jk . info () nazwa : Jan Kowalski stan : 1000 >>> jk . wplac ( 2000 ) >>> jk . wyplac ( 2500 ) >>> jk . info () nazwa : Jan Kowalski stan : 500 >>> jk . stan = 0 # Dost\u0119p do sk\u0142adowej `stan` >>> jk . info () nazwa : Jan Kowalski stan : 0 Zadanie 5 Wykorzystuj\u0105c implementacj\u0119 konta bankowego, zaimplementuj w nim metod\u0119 przelew() , kt\u00f3ra jako argument pierwszy bierze konto docelowe, a jako argument drugi bierze warto\u015b\u0107 przelewu. Przetestuj dzia\u0142anie klasy KontoBankowe .","title":"Przyk\u0142ad klasy - konto bankowe"},{"location":"obiekty.html","text":"Wszystko jest obiektem W Pythonie wszystko jest obiektem, a tym samym posiada pewien wsp\u00f3lny zestaw cech: To\u017csamo\u015b\u0107 ( identity ) \u2013 wskazuje na lokalizacj\u0119 obiektu w pami\u0119ci Typ ( type ) \u2013 opisuje reprezentacj\u0119 obiektu dla Pythona Warto\u015b\u0107 ( value ) \u2013 dane przechowywane w obiekcie >>> lst = [ 1 , 2 , 3 ] >>> id ( lst ) # to\u017csamo\u015b\u0107 30098576 >>> type ( lst ) # typ < type 'list' > >>> lst # warto\u015b\u0107 [ 1 , 2 , 3 ] Po utworzeniu obiektu jego to\u017csamo\u015b\u0107 i typ nie mog\u0105 by\u0107 zmienione. Je\u015bli warto\u015b\u0107 obiektu si\u0119 zmienia, jest to obiekt zmienny ( mutable ). Je\u015bli nie mo\u017ce ulec zmianie \u2013 obiekt niezmienny ( immutable ). Na przyk\u0142ad, typy str i tuple s\u0105 niezmienne. >>> t = ( 1 , 2 , 3 ) >>> t [ 0 ] = 2 Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object does not support item assignment >>> >>> s = \"Python jest spoko\" >>> s [ 0 ] = \"J\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment Co maj\u0105 obiekty? Obiekty posiadaj\u0105: Atrybuty (zwane r\u00f3wnie\u017c polami) \u2013 warto\u015bci powi\u0105zane z obiektem, mo\u017cna o nich my\u015ble\u0107 jako o w\u0142a\u015bciwo\u015bciach obiektu. Metody \u2013 wywo\u0142ywalne funkcje, kt\u00f3re operuj\u0105 na obiekcie. Dost\u0119p do atrybut\u00f3w i metod uzyskuje si\u0119 poprzez wykorzystanie sk\u0142adni z kropkami (.), poni\u017cej przyk\u0142ad zwi\u0105zany z otwieraniem pliku: >>> f = open ( \"test.txt\" , \"w\" ) # 'f' jest obiektem typu \"plik\" >>> f . closed # odwo\u0142anie do atrybutu \"closed\" False >>> f . close () # wywo\u0142anie metody, kt\u00f3ra zamyka plik >>> f . closed # zamkni\u0119cie pliku sprawi\u0142o, \u017ce atrybut \"closed\" zmieni\u0142 warto\u015b\u0107 True Dotychczas poznali\u015bmy r\u00f3\u017cne obiekty (typy podstawowe, np. liczby, ci\u0105gi znak\u00f3w, typy z\u0142o\u017cone, np. listy, tuple, s\u0142owniki, zbiory, czy pliki). Zadanie 1 Sprawd\u017a, w kt\u00f3rym z dotychczas poznanych typ\u00f3w danych mo\u017cesz dopisa\u0107 w\u0142asny, wcze\u015bniej nieistniej\u0105cy atrybut. Przyk\u0142adowo dla ci\u0105gu znak\u00f3w to nie zadzia\u0142a: >>> s = \"Python\" >>> s . test = True Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AttributeError : 'str' object has no attribute 'test' Zadanie 2 Jakie metody obiektu lista potrafisz wymieni\u0107?","title":"Obiekty"},{"location":"obiekty.html#wszystko-jest-obiektem","text":"W Pythonie wszystko jest obiektem, a tym samym posiada pewien wsp\u00f3lny zestaw cech: To\u017csamo\u015b\u0107 ( identity ) \u2013 wskazuje na lokalizacj\u0119 obiektu w pami\u0119ci Typ ( type ) \u2013 opisuje reprezentacj\u0119 obiektu dla Pythona Warto\u015b\u0107 ( value ) \u2013 dane przechowywane w obiekcie >>> lst = [ 1 , 2 , 3 ] >>> id ( lst ) # to\u017csamo\u015b\u0107 30098576 >>> type ( lst ) # typ < type 'list' > >>> lst # warto\u015b\u0107 [ 1 , 2 , 3 ] Po utworzeniu obiektu jego to\u017csamo\u015b\u0107 i typ nie mog\u0105 by\u0107 zmienione. Je\u015bli warto\u015b\u0107 obiektu si\u0119 zmienia, jest to obiekt zmienny ( mutable ). Je\u015bli nie mo\u017ce ulec zmianie \u2013 obiekt niezmienny ( immutable ). Na przyk\u0142ad, typy str i tuple s\u0105 niezmienne. >>> t = ( 1 , 2 , 3 ) >>> t [ 0 ] = 2 Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object does not support item assignment >>> >>> s = \"Python jest spoko\" >>> s [ 0 ] = \"J\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment","title":"Wszystko jest obiektem"},{"location":"obiekty.html#co-maja-obiekty","text":"Obiekty posiadaj\u0105: Atrybuty (zwane r\u00f3wnie\u017c polami) \u2013 warto\u015bci powi\u0105zane z obiektem, mo\u017cna o nich my\u015ble\u0107 jako o w\u0142a\u015bciwo\u015bciach obiektu. Metody \u2013 wywo\u0142ywalne funkcje, kt\u00f3re operuj\u0105 na obiekcie. Dost\u0119p do atrybut\u00f3w i metod uzyskuje si\u0119 poprzez wykorzystanie sk\u0142adni z kropkami (.), poni\u017cej przyk\u0142ad zwi\u0105zany z otwieraniem pliku: >>> f = open ( \"test.txt\" , \"w\" ) # 'f' jest obiektem typu \"plik\" >>> f . closed # odwo\u0142anie do atrybutu \"closed\" False >>> f . close () # wywo\u0142anie metody, kt\u00f3ra zamyka plik >>> f . closed # zamkni\u0119cie pliku sprawi\u0142o, \u017ce atrybut \"closed\" zmieni\u0142 warto\u015b\u0107 True Dotychczas poznali\u015bmy r\u00f3\u017cne obiekty (typy podstawowe, np. liczby, ci\u0105gi znak\u00f3w, typy z\u0142o\u017cone, np. listy, tuple, s\u0142owniki, zbiory, czy pliki). Zadanie 1 Sprawd\u017a, w kt\u00f3rym z dotychczas poznanych typ\u00f3w danych mo\u017cesz dopisa\u0107 w\u0142asny, wcze\u015bniej nieistniej\u0105cy atrybut. Przyk\u0142adowo dla ci\u0105gu znak\u00f3w to nie zadzia\u0142a: >>> s = \"Python\" >>> s . test = True Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AttributeError : 'str' object has no attribute 'test' Zadanie 2 Jakie metody obiektu lista potrafisz wymieni\u0107?","title":"Co maj\u0105 obiekty?"},{"location":"programowanie_funkcyjne.html","text":"Funkcje anonimowe (lambda) Python umo\u017cliwia tworzenie funkcji w miejscu, bez osobnego deklarowania ich. Takie funkcje nazywane s\u0105 \"anonimowe\", bo nie musz\u0105 przyjmowa\u0107 nazw, a wykorzystuje si\u0119 je cz\u0119sto jako np. argumenty do \"normalnych\" funkcji. Podstawowa sk\u0142adania funkcji anonimowej jest nast\u0119puj\u0105ca: lambda arg1, arg2: arg1 ** arg2 \\--------/ \\----------/ argumenty operacja, kt\u00f3rej wynik jest zwracany przez funkcj\u0119 Podobie\u0144stwo do Excela Operacja funkcji lambda jest niemal identyczna jak zawarto\u015b\u0107 funkcji w kom\u00f3rce w Excelu. R\u00f3\u017cnic\u0105 jest jedynie odwo\u0142ywanie do zmiennych (Python) i nazw kom\u00f3rek (Excel). Przyk\u0142ad funkcji anonimowej obliczaj\u0105cej przeciwprostok\u0105tn\u0105 w tr\u00f3jk\u0105cie prostok\u0105tnym (twierdzenie Pitagorasa): lambda a , b : (( a * a ) + ( b * b )) ** 0.5 Przypomnienie Twierdzenie Pitagorasa: c*c = a*a + b*b . Operator ** to podnoszenie do pot\u0119gi. Je\u015bli wyk\u0142adnik pot\u0119gi ma posta\u0107 1/n (w powy\u017cszym przyk\u0142adzie: 1/2 ), to takie pot\u0119gowanie zamienia si\u0119 w pierwiastkowanie o stopniu n . Funkcje anonimowe s\u0105 obiektami w Pythonie i dzi\u0119ki temu mo\u017cemy je przypisa\u0107 w taki sam spos\u00f3b, jak przypisanie warto\u015bci do zmiennej: pitagoras = lambda a , b : (( a * a ) + ( b * b )) ** 0.5 Pozwala to w dalszym kodzie np. wywo\u0142ywa\u0107 tak\u0105 funkcj\u0119 anonimow\u0105 po jej, de facto, nazwie: >>> pitagoras = lambda a , b : (( a * a ) + ( b * b )) ** 0.5 >>> pitagoras ( 3 , 4 ) 5.0 Zadanie 1 Napisz funkcj\u0119 anonimow\u0105 obliczaj\u0105c\u0105 kwadrat danej warto\u015bci. Czy potrafisz wyt\u0142umaczy\u0107 czym si\u0119 to r\u00f3\u017cni od wykorzystania funkcji pow(a, b) lub operatora a ** b ? Zadanie 2 Napisz funkcj\u0119 anonimow\u0105 obliczaj\u0105c\u0105 \u015bredni\u0105 arytmetyczn\u0105 dw\u00f3ch warto\u015bci. Zadanie 3 Napisz funkcj\u0119 anonimow\u0105 sprawdzaj\u0105c\u0105 czy dana warto\u015b\u0107 jest wi\u0119ksza (lub mniejsza) od pewnej warto\u015bci. Taka funkcja anonimowa powinna zwraca\u0107 warto\u015b\u0107 logiczn\u0105. Filtrowanie, aplikowanie, redukowanie W Pythonie istnieje kilka przydatnych funkcji wykorzystuj\u0105cych funkcje anonimowe i pracuj\u0105cych na zbiorach danych: filter(funkcja, iterator) : zwraca tylko te warto\u015bci ze zbioru danych, dla kt\u00f3rych funkcja(warto\u015b\u0107) zwr\u00f3ci\u0142a True . map(funkcja, iterator) : aplikuje funkcj\u0119 dla ka\u017cdej warto\u015bci. reduce(funkcja, iterator) : s\u0142u\u017cy do zredukowania ca\u0142ego zbioru danych do jednej warto\u015bci. Filtrowanie Dla przyk\u0142ad\u00f3w u\u017cyj\u0119 prostego zbioru danych temperatury: >>> temperatury = [ 37.6 , 35.8 , 37.6 , 33.4 , 34.1 , 37.1 , 35.9 , 34.1 , 37.1 , 40.5 , 38.5 , 37.6 , 35.8 , 34.5 , 36.4 , 38.3 , 37.5 , 37.7 , 34.0 , 35.3 , 35.7 , 38.9 , 34.8 , 34.1 , 39.6 , 35.4 , 34.7 , 37.6 , 38.4 , 36.4 , 39.8 , 39.1 , 37.1 , 35.6 , 36.8 , 37.6 , 36.7 , 40.0 , 38.0 , 34.1 , 35.5 , 38.5 , 36.1 , 32.6 , 32.9 , 34.5 , 41.0 , 38.3 , 33.7 , 38.7 , 36.9 , 36.2 , 33.7 , 38.3 , 35.3 , 38.3 , 40.1 , 39.3 , 38.2 , 37.6 , 39.1 , 37.1 , 34.4 , 38.7 , 35.8 , 38.2 , 38.2 , 33.1 , 37.8 , 36.5 , 37.6 , 37.4 , 34.3 , 37.7 , 36.0 , 37.5 , 37.6 , 36.5 , 31.3 , 37.7 , 40.3 , 39.5 , 35.7 , 38.1 , 34.7 , 36.5 , 34.3 , 38.0 , 37.0 , 38.5 , 39.4 , 37.6 , 41.7 , 40.0 , 38.4 , 38.9 , 34.2 , 40.2 , 34.3 , 35.3 ] U\u017cyjmy teraz funkcji filtruj\u0105cej, \u017ceby znale\u017a\u0107 wszystkie warto\u015bci wi\u0119ksze lub r\u00f3wne 40.0 : >>> list ( filter ( lambda x : x >= 40.0 , temperatury )) [ 40.5 , 40.0 , 41.0 , 40.1 , 40.3 , 41.7 , 40.0 , 40.2 ] Zadanie 4 Znajd\u017a wszystkie warto\u015bci mniejsze od 36.6 . Zadanie 5 Odfiltruj wszystkie warto\u015bci, kt\u00f3re s\u0105 mniejsze b\u0105d\u017a r\u00f3wne 35 lub wi\u0119ksze b\u0105d\u017a r\u00f3wne 40. Aplikowanie Zacznijmy od znalezienia \u015bredniej warto\u015bci temperatury: >>> from statistics import mean >>> sr_temp = mean ( temperatury ) >>> sr_temp 36.9 Teraz mo\u017cna \u0142atwo obliczy\u0107 warto\u015bci odchylenia od \u015bredniej zbioru - przydatne w statystyce: >>> list ( map ( lambda x : x - sr_temp , temperatury )) [ 0.7 , - 1.1 , 0.7 , - 3.5 , - 2.8 , 0.2 , - 1.0 , - 2.8 , 0.2 , 3.6 , 1.6 , 0.7 , - 1.1 , - 2.4 , - 0.5 , 1.4 , 0.6 , 0.8 , - 2.9 , - 1.6 , - 1.2 , 2.0 , - 2.1 , - 2.8 , 2.7 , - 1.5 , - 2.2 , 0.7 , 1.5 , - 0.5 , 2.9 , 2.2 , 0.2 , - 1.3 , - 0.1 , 0.7 , - 0.2 , 3.1 , 1.1 , - 2.8 , - 1.4 , 1.6 , - 0.8 , - 4.3 , - 4.0 , - 2.4 , 4.1 , 1.4 , - 3.2 , 1.8 , 0.0 , - 0.7 , - 3.2 , 1.4 , - 1.6 , 1.4 , 3.2 , 2.4 , 1.3 , 0.7 , 2.2 , 0.2 , - 2.5 , 1.8 , - 1.1 , 1.3 , 1.3 , - 3.8 , 0.9 , - 0.4 , 0.7 , 0.5 , - 2.6 , 0.8 , - 0.9 , 0.6 , 0.7 , - 0.4 , - 5.6 , 0.8 , 3.4 , 2.6 , - 1.2 , 1.2 , - 2.2 , - 0.4 , - 2.6 , 1.1 , 0.1 , 1.6 , 2.5 , 0.7 , 4.8 , 3.1 , 1.5 , 2.0 , - 2.7 , 3.3 , - 2.6 , - 1.6 ] Format liczb zmiennoprzecinkowych Podczas test\u00f3w powy\u017cszego kodu, Python potrafi\u0142 zamiast warto\u015bci 0.7 zwr\u00f3ci\u0107 0.7000000000000028 , dlatego dla uproszczonego zapisu wszystkie warto\u015bci zosta\u0142y zaokr\u0105glone do jednego miejsca po przecinku. Zadanie 6 Oblicz dla ka\u017cdej liczby w zbiorze temperatur kwadrat r\u00f3\u017cnicy tej liczby i \u015bredniej arytmetycznej ca\u0142ego zbioru. Redukowanie Funkcja reduce z modu\u0142u functools pomaga w iteratywnym redukowaniu zbioru warto\u015bci do jednej warto\u015bci. \u017beby to lepiej zobrazowa\u0107, poka\u017c\u0119 dwa przyk\u0142ady u\u017cycia reduce do obliczenia sumy warto\u015bci i ich iloczynu. Przyk\u0142ad 1: obliczenie sumy >>> from functools import reduce >>> reduce ( lambda a , b : a + b , [ 1 , 2 , 3 , 4 , 5 ]) 15 Wykorzystanie funkcji reduce w powy\u017cszym przyk\u0142adzie sprowadza si\u0119 tak naprawd\u0119 do: ((((1 + 2) + 3) + 4) + 5) Przyk\u0142ad 2: obliczenie iloczynu >>> reduce ( lambda a , b : a * b , [ 1 , 2 , 3 , 4 ]) 24 Sprowadza si\u0119 to do: (((1 * 2) * 3) * 4) . Zadanie 7 Maj\u0105c obliczone warto\u015bci odchyle\u0144 temperatur od \u015bredniej temperatury, oblicz wariancj\u0119 tych warto\u015bci. Nie zapomnij o podzieleniu przez ilo\u015b\u0107 element\u00f3w w zbiorze! Tworzenie zbior\u00f3w danych w locie Tworzenie list - list comprehension Dzi\u0119ki generowaniu list w locie mo\u017cemy nawet do\u015b\u0107 skomplikowane p\u0119tle zamieni\u0107 na pojedyncze linijki kodu. Przyk\u0142adowo 4 linijki kodu generuj\u0105ce list\u0119 sze\u015bcian\u00f3w. szesciany = [] for x in range ( 10 ): szesciany . append ( x ** 3 ) W podstawowej wersji mo\u017cemy \"przenie\u015b\u0107\" p\u0119tl\u0119 do nawias\u00f3w kwadratowych: szesciany = [ x ** 3 for x in range ( 10 )] Og\u00f3lniejsza posta\u0107 list comprehension : nowa_lista = [ funkcja ( element ) for element in lista if warunek ( element )] Na przyk\u0142ad by przygotowa\u0107 list\u0119 kwadrat\u00f3w liczb nieparzystych z zakresu od 1 do 100: kwadraty = [ el ** 2 for el in range ( 1 , 101 ) if el % 2 == 0 ] Zadanie 1 Napisz pogram, kt\u00f3ry policzy kwadraty liczb z zakresu [1,10000], kt\u00f3re podzielne s\u0105 przez 5 lub 9. Nast\u0119pnie sprawd\u017a, kt\u00f3re z uzyskanych liczb s\u0105 podzielne zar\u00f3wno przez 5 jak i przez 9. Tworzenie zbior\u00f3w W podobny spos\u00f3b mo\u017cna te\u017c przygotowa\u0107 zbi\u00f3r. zbior = { znak for znak in \"abracadabra\" if znak not in \"abc\" } Zadanie 2 Stw\u00f3rz zbi\u00f3r, kt\u00f3ry wype\u0142nisz 30 wywo\u0142aniami funkcji random.randint(1, 30) . Ile razy wylosowana zosta\u0142a ta sama warto\u015b\u0107? (Sprawdzisz to por\u00f3wnuj\u0105c ilo\u015b\u0107 element\u00f3w zbioru). Jak si\u0119 zachowa program, je\u015bli zmienisz argumenty do funkcji randint ? A je\u015bli zmienisz ilo\u015b\u0107 wywo\u0142a\u0144 tej funkcji? Tworzenie s\u0142ownik\u00f3w Podobnie mo\u017cna stworzy\u0107 s\u0142ownik: tekst = \"abracadabra\" wystapienia = { znak : tekst . count ( znak ) for znak in tekst } Wyra\u017cenia generatorowe - generator expressions Co do zapisu: nie r\u00f3\u017cni\u0105 si\u0119 niczym od list comprehension , poza zmian\u0105 znak\u00f3w nawiasa z [] na () : list_comp = [ x ** 0.5 for x in range ( 1 , 11 )] gen_expr = ( x ** 0.5 for x in range ( 1 , 11 )) R\u00f3\u017cnica polega na tym, \u017ce list comprehension tworzy list\u0119, a wi\u0119c zajmuje miejsce w pami\u0119ci i czas procesora. Wyra\u017cenie generatorowe jest dopiero obliczane przy przechodzeniu przez nie, np. w formie p\u0119tli for : gen_expr = ( x ** 0.5 for x in range ( 1 , 10000001 )) # gen_expr nie obliczy\u0142o jeszcze tych 10 milion\u00f3w pierwiastk\u00f3w for x in gen_expr : # teraz ju\u017c kolejne elementy wyra\u017cenia generatorowego s\u0105 obliczane print ( x )","title":"Programowanie funkcyjne"},{"location":"programowanie_funkcyjne.html#funkcje-anonimowe-lambda","text":"Python umo\u017cliwia tworzenie funkcji w miejscu, bez osobnego deklarowania ich. Takie funkcje nazywane s\u0105 \"anonimowe\", bo nie musz\u0105 przyjmowa\u0107 nazw, a wykorzystuje si\u0119 je cz\u0119sto jako np. argumenty do \"normalnych\" funkcji. Podstawowa sk\u0142adania funkcji anonimowej jest nast\u0119puj\u0105ca: lambda arg1, arg2: arg1 ** arg2 \\--------/ \\----------/ argumenty operacja, kt\u00f3rej wynik jest zwracany przez funkcj\u0119 Podobie\u0144stwo do Excela Operacja funkcji lambda jest niemal identyczna jak zawarto\u015b\u0107 funkcji w kom\u00f3rce w Excelu. R\u00f3\u017cnic\u0105 jest jedynie odwo\u0142ywanie do zmiennych (Python) i nazw kom\u00f3rek (Excel). Przyk\u0142ad funkcji anonimowej obliczaj\u0105cej przeciwprostok\u0105tn\u0105 w tr\u00f3jk\u0105cie prostok\u0105tnym (twierdzenie Pitagorasa): lambda a , b : (( a * a ) + ( b * b )) ** 0.5 Przypomnienie Twierdzenie Pitagorasa: c*c = a*a + b*b . Operator ** to podnoszenie do pot\u0119gi. Je\u015bli wyk\u0142adnik pot\u0119gi ma posta\u0107 1/n (w powy\u017cszym przyk\u0142adzie: 1/2 ), to takie pot\u0119gowanie zamienia si\u0119 w pierwiastkowanie o stopniu n . Funkcje anonimowe s\u0105 obiektami w Pythonie i dzi\u0119ki temu mo\u017cemy je przypisa\u0107 w taki sam spos\u00f3b, jak przypisanie warto\u015bci do zmiennej: pitagoras = lambda a , b : (( a * a ) + ( b * b )) ** 0.5 Pozwala to w dalszym kodzie np. wywo\u0142ywa\u0107 tak\u0105 funkcj\u0119 anonimow\u0105 po jej, de facto, nazwie: >>> pitagoras = lambda a , b : (( a * a ) + ( b * b )) ** 0.5 >>> pitagoras ( 3 , 4 ) 5.0 Zadanie 1 Napisz funkcj\u0119 anonimow\u0105 obliczaj\u0105c\u0105 kwadrat danej warto\u015bci. Czy potrafisz wyt\u0142umaczy\u0107 czym si\u0119 to r\u00f3\u017cni od wykorzystania funkcji pow(a, b) lub operatora a ** b ? Zadanie 2 Napisz funkcj\u0119 anonimow\u0105 obliczaj\u0105c\u0105 \u015bredni\u0105 arytmetyczn\u0105 dw\u00f3ch warto\u015bci. Zadanie 3 Napisz funkcj\u0119 anonimow\u0105 sprawdzaj\u0105c\u0105 czy dana warto\u015b\u0107 jest wi\u0119ksza (lub mniejsza) od pewnej warto\u015bci. Taka funkcja anonimowa powinna zwraca\u0107 warto\u015b\u0107 logiczn\u0105.","title":"Funkcje anonimowe (lambda)"},{"location":"programowanie_funkcyjne.html#filtrowanie-aplikowanie-redukowanie","text":"W Pythonie istnieje kilka przydatnych funkcji wykorzystuj\u0105cych funkcje anonimowe i pracuj\u0105cych na zbiorach danych: filter(funkcja, iterator) : zwraca tylko te warto\u015bci ze zbioru danych, dla kt\u00f3rych funkcja(warto\u015b\u0107) zwr\u00f3ci\u0142a True . map(funkcja, iterator) : aplikuje funkcj\u0119 dla ka\u017cdej warto\u015bci. reduce(funkcja, iterator) : s\u0142u\u017cy do zredukowania ca\u0142ego zbioru danych do jednej warto\u015bci.","title":"Filtrowanie, aplikowanie, redukowanie"},{"location":"programowanie_funkcyjne.html#filtrowanie","text":"Dla przyk\u0142ad\u00f3w u\u017cyj\u0119 prostego zbioru danych temperatury: >>> temperatury = [ 37.6 , 35.8 , 37.6 , 33.4 , 34.1 , 37.1 , 35.9 , 34.1 , 37.1 , 40.5 , 38.5 , 37.6 , 35.8 , 34.5 , 36.4 , 38.3 , 37.5 , 37.7 , 34.0 , 35.3 , 35.7 , 38.9 , 34.8 , 34.1 , 39.6 , 35.4 , 34.7 , 37.6 , 38.4 , 36.4 , 39.8 , 39.1 , 37.1 , 35.6 , 36.8 , 37.6 , 36.7 , 40.0 , 38.0 , 34.1 , 35.5 , 38.5 , 36.1 , 32.6 , 32.9 , 34.5 , 41.0 , 38.3 , 33.7 , 38.7 , 36.9 , 36.2 , 33.7 , 38.3 , 35.3 , 38.3 , 40.1 , 39.3 , 38.2 , 37.6 , 39.1 , 37.1 , 34.4 , 38.7 , 35.8 , 38.2 , 38.2 , 33.1 , 37.8 , 36.5 , 37.6 , 37.4 , 34.3 , 37.7 , 36.0 , 37.5 , 37.6 , 36.5 , 31.3 , 37.7 , 40.3 , 39.5 , 35.7 , 38.1 , 34.7 , 36.5 , 34.3 , 38.0 , 37.0 , 38.5 , 39.4 , 37.6 , 41.7 , 40.0 , 38.4 , 38.9 , 34.2 , 40.2 , 34.3 , 35.3 ] U\u017cyjmy teraz funkcji filtruj\u0105cej, \u017ceby znale\u017a\u0107 wszystkie warto\u015bci wi\u0119ksze lub r\u00f3wne 40.0 : >>> list ( filter ( lambda x : x >= 40.0 , temperatury )) [ 40.5 , 40.0 , 41.0 , 40.1 , 40.3 , 41.7 , 40.0 , 40.2 ] Zadanie 4 Znajd\u017a wszystkie warto\u015bci mniejsze od 36.6 . Zadanie 5 Odfiltruj wszystkie warto\u015bci, kt\u00f3re s\u0105 mniejsze b\u0105d\u017a r\u00f3wne 35 lub wi\u0119ksze b\u0105d\u017a r\u00f3wne 40.","title":"Filtrowanie"},{"location":"programowanie_funkcyjne.html#aplikowanie","text":"Zacznijmy od znalezienia \u015bredniej warto\u015bci temperatury: >>> from statistics import mean >>> sr_temp = mean ( temperatury ) >>> sr_temp 36.9 Teraz mo\u017cna \u0142atwo obliczy\u0107 warto\u015bci odchylenia od \u015bredniej zbioru - przydatne w statystyce: >>> list ( map ( lambda x : x - sr_temp , temperatury )) [ 0.7 , - 1.1 , 0.7 , - 3.5 , - 2.8 , 0.2 , - 1.0 , - 2.8 , 0.2 , 3.6 , 1.6 , 0.7 , - 1.1 , - 2.4 , - 0.5 , 1.4 , 0.6 , 0.8 , - 2.9 , - 1.6 , - 1.2 , 2.0 , - 2.1 , - 2.8 , 2.7 , - 1.5 , - 2.2 , 0.7 , 1.5 , - 0.5 , 2.9 , 2.2 , 0.2 , - 1.3 , - 0.1 , 0.7 , - 0.2 , 3.1 , 1.1 , - 2.8 , - 1.4 , 1.6 , - 0.8 , - 4.3 , - 4.0 , - 2.4 , 4.1 , 1.4 , - 3.2 , 1.8 , 0.0 , - 0.7 , - 3.2 , 1.4 , - 1.6 , 1.4 , 3.2 , 2.4 , 1.3 , 0.7 , 2.2 , 0.2 , - 2.5 , 1.8 , - 1.1 , 1.3 , 1.3 , - 3.8 , 0.9 , - 0.4 , 0.7 , 0.5 , - 2.6 , 0.8 , - 0.9 , 0.6 , 0.7 , - 0.4 , - 5.6 , 0.8 , 3.4 , 2.6 , - 1.2 , 1.2 , - 2.2 , - 0.4 , - 2.6 , 1.1 , 0.1 , 1.6 , 2.5 , 0.7 , 4.8 , 3.1 , 1.5 , 2.0 , - 2.7 , 3.3 , - 2.6 , - 1.6 ] Format liczb zmiennoprzecinkowych Podczas test\u00f3w powy\u017cszego kodu, Python potrafi\u0142 zamiast warto\u015bci 0.7 zwr\u00f3ci\u0107 0.7000000000000028 , dlatego dla uproszczonego zapisu wszystkie warto\u015bci zosta\u0142y zaokr\u0105glone do jednego miejsca po przecinku. Zadanie 6 Oblicz dla ka\u017cdej liczby w zbiorze temperatur kwadrat r\u00f3\u017cnicy tej liczby i \u015bredniej arytmetycznej ca\u0142ego zbioru.","title":"Aplikowanie"},{"location":"programowanie_funkcyjne.html#redukowanie","text":"Funkcja reduce z modu\u0142u functools pomaga w iteratywnym redukowaniu zbioru warto\u015bci do jednej warto\u015bci. \u017beby to lepiej zobrazowa\u0107, poka\u017c\u0119 dwa przyk\u0142ady u\u017cycia reduce do obliczenia sumy warto\u015bci i ich iloczynu. Przyk\u0142ad 1: obliczenie sumy >>> from functools import reduce >>> reduce ( lambda a , b : a + b , [ 1 , 2 , 3 , 4 , 5 ]) 15 Wykorzystanie funkcji reduce w powy\u017cszym przyk\u0142adzie sprowadza si\u0119 tak naprawd\u0119 do: ((((1 + 2) + 3) + 4) + 5) Przyk\u0142ad 2: obliczenie iloczynu >>> reduce ( lambda a , b : a * b , [ 1 , 2 , 3 , 4 ]) 24 Sprowadza si\u0119 to do: (((1 * 2) * 3) * 4) . Zadanie 7 Maj\u0105c obliczone warto\u015bci odchyle\u0144 temperatur od \u015bredniej temperatury, oblicz wariancj\u0119 tych warto\u015bci. Nie zapomnij o podzieleniu przez ilo\u015b\u0107 element\u00f3w w zbiorze!","title":"Redukowanie"},{"location":"programowanie_funkcyjne.html#tworzenie-zbiorow-danych-w-locie","text":"","title":"Tworzenie zbior\u00f3w danych w locie"},{"location":"programowanie_funkcyjne.html#tworzenie-list-list-comprehension","text":"Dzi\u0119ki generowaniu list w locie mo\u017cemy nawet do\u015b\u0107 skomplikowane p\u0119tle zamieni\u0107 na pojedyncze linijki kodu. Przyk\u0142adowo 4 linijki kodu generuj\u0105ce list\u0119 sze\u015bcian\u00f3w. szesciany = [] for x in range ( 10 ): szesciany . append ( x ** 3 ) W podstawowej wersji mo\u017cemy \"przenie\u015b\u0107\" p\u0119tl\u0119 do nawias\u00f3w kwadratowych: szesciany = [ x ** 3 for x in range ( 10 )] Og\u00f3lniejsza posta\u0107 list comprehension : nowa_lista = [ funkcja ( element ) for element in lista if warunek ( element )] Na przyk\u0142ad by przygotowa\u0107 list\u0119 kwadrat\u00f3w liczb nieparzystych z zakresu od 1 do 100: kwadraty = [ el ** 2 for el in range ( 1 , 101 ) if el % 2 == 0 ] Zadanie 1 Napisz pogram, kt\u00f3ry policzy kwadraty liczb z zakresu [1,10000], kt\u00f3re podzielne s\u0105 przez 5 lub 9. Nast\u0119pnie sprawd\u017a, kt\u00f3re z uzyskanych liczb s\u0105 podzielne zar\u00f3wno przez 5 jak i przez 9.","title":"Tworzenie list - list comprehension"},{"location":"programowanie_funkcyjne.html#tworzenie-zbiorow","text":"W podobny spos\u00f3b mo\u017cna te\u017c przygotowa\u0107 zbi\u00f3r. zbior = { znak for znak in \"abracadabra\" if znak not in \"abc\" } Zadanie 2 Stw\u00f3rz zbi\u00f3r, kt\u00f3ry wype\u0142nisz 30 wywo\u0142aniami funkcji random.randint(1, 30) . Ile razy wylosowana zosta\u0142a ta sama warto\u015b\u0107? (Sprawdzisz to por\u00f3wnuj\u0105c ilo\u015b\u0107 element\u00f3w zbioru). Jak si\u0119 zachowa program, je\u015bli zmienisz argumenty do funkcji randint ? A je\u015bli zmienisz ilo\u015b\u0107 wywo\u0142a\u0144 tej funkcji?","title":"Tworzenie zbior\u00f3w"},{"location":"programowanie_funkcyjne.html#tworzenie-sownikow","text":"Podobnie mo\u017cna stworzy\u0107 s\u0142ownik: tekst = \"abracadabra\" wystapienia = { znak : tekst . count ( znak ) for znak in tekst }","title":"Tworzenie s\u0142ownik\u00f3w"},{"location":"programowanie_funkcyjne.html#wyrazenia-generatorowe-generator-expressions","text":"Co do zapisu: nie r\u00f3\u017cni\u0105 si\u0119 niczym od list comprehension , poza zmian\u0105 znak\u00f3w nawiasa z [] na () : list_comp = [ x ** 0.5 for x in range ( 1 , 11 )] gen_expr = ( x ** 0.5 for x in range ( 1 , 11 )) R\u00f3\u017cnica polega na tym, \u017ce list comprehension tworzy list\u0119, a wi\u0119c zajmuje miejsce w pami\u0119ci i czas procesora. Wyra\u017cenie generatorowe jest dopiero obliczane przy przechodzeniu przez nie, np. w formie p\u0119tli for : gen_expr = ( x ** 0.5 for x in range ( 1 , 10000001 )) # gen_expr nie obliczy\u0142o jeszcze tych 10 milion\u00f3w pierwiastk\u00f3w for x in gen_expr : # teraz ju\u017c kolejne elementy wyra\u017cenia generatorowego s\u0105 obliczane print ( x )","title":"Wyra\u017cenia generatorowe - generator expressions"},{"location":"serializacja.html","text":"Serializacja i trwa\u0142o\u015b\u0107 obiekt\u00f3w Modu\u0142 pickle Serializacja i trwa\u0142o\u015b\u0107 obiekt\u00f3w mo\u017ce zosta\u0107 zrealizowana przy pomocy wbudowanych narz\u0119dzi Pythona. Modu\u0142 pickle serializuje obiekty do i z plik\u00f3w. import pickle p = pickle . Pickler ( file ) # file to otwarty obiekt pliku p . dump ( obj ) # Zrzut obiektu Aby odserializowa\u0107 obiekt, u\u017cywamy funkcji unpickle. p = pickle . Unpickler ( file ) # file to otwarty obiekt pliku obj = p . load () # \u0141adowanie obiektu Serializacja - wskaz\u00f3wki Wi\u0119kszo\u015b\u0107 typ\u00f3w wbudowanych mo\u017cna podda\u0107 serializacji. Mo\u017cna dokona\u0107 serializacji obiektu klasy. Klasa musi by\u0107 dost\u0119pna w momencie odtwarzania obiektu. Sam kod klasy nie jest serializowany. Python automatycznie importuje modu\u0142 zawieraj\u0105cy odtwarzan\u0105 klas\u0119. Pewne typy obiekt\u00f3w nie mog\u0105 by\u0107 serializowane np. sockety, pliki. Dowolny obiekt zapewniaj\u0105cy metody write(), read() i readline() mo\u017ce by\u0107 u\u017cywany jako plik. Obiekty rekursywne mo\u017cna podda\u0107 serializacji. Dane po serializacji mo\u017cna przenosi\u0107 mi\u0119dzy r\u00f3\u017cnymi systemami operacyjnymi i architekturami sprz\u0119towymi. Serializacja obiekt\u00f3w zastosowana w Pythonie nie jest dost\u0119pna z poziomu program\u00f3w napisanych w innych j\u0119zykach programowania. Modu\u0142 shelve Modu\u0142 shelve umo\u017cliwia prosty zapis serializowanych danych do pliku z wykorzystaniem sk\u0142adni s\u0142ownika. Klucze musz\u0105 by\u0107 ci\u0105gami znak\u00f3w. Warto\u015bciami mog\u0105 by\u0107 dowolne obiekty Pythona dla kt\u00f3rych dzia\u0142a modu\u0142 pickle . import shelve d = shelve . open ( \"data\" ) d [ 'foo' ] = 42 # Zapis danych do pliku x = d [ 'bar' ] # Odczyt danych z pliku","title":"Serializacja"},{"location":"serializacja.html#serializacja-i-trwaosc-obiektow","text":"","title":"Serializacja i trwa\u0142o\u015b\u0107 obiekt\u00f3w"},{"location":"serializacja.html#modu-pickle","text":"Serializacja i trwa\u0142o\u015b\u0107 obiekt\u00f3w mo\u017ce zosta\u0107 zrealizowana przy pomocy wbudowanych narz\u0119dzi Pythona. Modu\u0142 pickle serializuje obiekty do i z plik\u00f3w. import pickle p = pickle . Pickler ( file ) # file to otwarty obiekt pliku p . dump ( obj ) # Zrzut obiektu Aby odserializowa\u0107 obiekt, u\u017cywamy funkcji unpickle. p = pickle . Unpickler ( file ) # file to otwarty obiekt pliku obj = p . load () # \u0141adowanie obiektu","title":"Modu\u0142 pickle"},{"location":"serializacja.html#serializacja-wskazowki","text":"Wi\u0119kszo\u015b\u0107 typ\u00f3w wbudowanych mo\u017cna podda\u0107 serializacji. Mo\u017cna dokona\u0107 serializacji obiektu klasy. Klasa musi by\u0107 dost\u0119pna w momencie odtwarzania obiektu. Sam kod klasy nie jest serializowany. Python automatycznie importuje modu\u0142 zawieraj\u0105cy odtwarzan\u0105 klas\u0119. Pewne typy obiekt\u00f3w nie mog\u0105 by\u0107 serializowane np. sockety, pliki. Dowolny obiekt zapewniaj\u0105cy metody write(), read() i readline() mo\u017ce by\u0107 u\u017cywany jako plik. Obiekty rekursywne mo\u017cna podda\u0107 serializacji. Dane po serializacji mo\u017cna przenosi\u0107 mi\u0119dzy r\u00f3\u017cnymi systemami operacyjnymi i architekturami sprz\u0119towymi. Serializacja obiekt\u00f3w zastosowana w Pythonie nie jest dost\u0119pna z poziomu program\u00f3w napisanych w innych j\u0119zykach programowania.","title":"Serializacja - wskaz\u00f3wki"},{"location":"serializacja.html#modu-shelve","text":"Modu\u0142 shelve umo\u017cliwia prosty zapis serializowanych danych do pliku z wykorzystaniem sk\u0142adni s\u0142ownika. Klucze musz\u0105 by\u0107 ci\u0105gami znak\u00f3w. Warto\u015bciami mog\u0105 by\u0107 dowolne obiekty Pythona dla kt\u00f3rych dzia\u0142a modu\u0142 pickle . import shelve d = shelve . open ( \"data\" ) d [ 'foo' ] = 42 # Zapis danych do pliku x = d [ 'bar' ] # Odczyt danych z pliku","title":"Modu\u0142 shelve"},{"location":"zaawansowane_oop.html","text":"Zaawansowane kwestie OOP Interfejsy i introspekcja Istnieje mo\u017cliwo\u015b\u0107 sprawdzania charakterystyk klas i obiekt\u00f3w w trakcie dzia\u0142ania programu. >>> issubclass ( Pochodna , A ) True >>> issubclass ( B , Pochodna ) False >>> Pochodna . __bases__ ( < class ' __main__ . B '>, <class ' __main__ . A '>) >>> d = Pochodna () >>> isinstance ( d , A ) True >>> hasattr ( d , \"fa\" ) True >>> callable ( getattr ( d , \"fa\" , None )) True Sk\u0142adowe prywatne klasy Wszystkie atrybuty i metody zdefiniowane w klasie s\u0105 publiczne. Aby ukry\u0107 atrybut lub metod\u0119 przed dost\u0119pem spoza klasy (sk\u0142adowa private) nale\u017cy jej nazw\u0119 poprzedzi\u0107 dwoma podkre\u015blnikami (np. __atrybut ). class KontoBankowe : def __init__ ( self , nazwa , stan = 0 ): self . nazwa = nazwa self . __stan = stan def info ( self ): print ( \"nazwa:\" , self . nazwa ) print ( \"stan:\" , self . __stan ) def wyplac ( self , ilosc ): self . __stan -= ilosc def wplac ( self , ilosc ): self . __stan += ilosc jk = KontoBankowe ( \"Kowalski\" , 1000 ) print ( jk . stan ) # B\u0142\u0105d! print ( jk . __stan ) # B\u0142\u0105d! print ( jk . _KontoBankowe__stan ) # OK Sk\u0142adowe statyczne Sk\u0142adowe statyczne s\u0105 wsp\u00f3lne dla wszystkich instancji klasy. class CountedObject : __count = 0 # Statyczna skladowa def __init__ ( self ): CountedObject . __count += 1 @staticmethod def staticGetCount (): return CountedObject . __count @classmethod def classGetCount ( cls ): print ( \"classGetCount invoked for instance of\" , cls ) return cls . __count print ( \"Number of objects: %s \" % CountedObject . staticGetCount ()) print ( \"Creating objects...\" ) c1 = CountedObject () c2 = CountedObject () cs = [ CountedObject (), CountedObject ()] print ( \"Number of objects: %s \" % CountedObject . staticGetCount ()) print ( \"Number of objects: %s \" % CountedObject . classGetCount ()) Dzia\u0142anie: Number of objects: 0 Creating objects... Number of objects: 4 classGetCount invoked for instance of <class '__main__.CountedObject'> W\u0142a\u015bciwo\u015bci W\u0142a\u015bciwo\u015bci (nie myli\u0107 z atrybutami!), zwane r\u00f3wnie\u017c jako gettery i settery, umo\u017cliwiaj\u0105 enkapsulacj\u0119 obiektu. S\u0105 odpowiednikiem metod dost\u0119powych. class Rectangle : def __init__ ( self ): self . width = 0 self . height = 0 def setSize ( self , size ): self . width , self . height = size def getSize ( self ): return self . width , self . height size = property ( getSize , setSize ) Przyk\u0142ad u\u017cycia: >>> r = Rectangle () >>> r . width = 10 >>> r . height = 20 >>> r . size ( 10 , 20 ) >>> r . size = 150 , 100 >>> r . height 100 Istnieje mo\u017cliwo\u015b\u0107 definiowania w\u0142a\u015bciwo\u015bci typu \"read-only\". Poni\u017cej przyk\u0142ad konta bankowego, w kt\u00f3rym mo\u017cna odczyta\u0107 stan konta, ale nie mo\u017cna go zmieni\u0107. class BankAccount : counter = 0 def __init__ ( self , owner , balance = 0 ): self . owner = owner self . __balance = balance BankAccount . counter += 1 def __getBalance ( self ): return self . __balance balance = property ( __getBalance ) U\u017cycie: >>> ba = BankAccount ( \"jk\" , 100 ) >>> ba . balance 100 >>> ba . balance = 100 # B\u0142\u0105d! \u2003 Atrybuty specjalne Instancje klas posiadaj\u0105 specjalne atrybuty, kt\u00f3re opisuj\u0105 obiekty. :: >>> ba = BankAccount ( \"Kowalski\" , 1000 ) >>> ba . __dict__ # S\u0142ownik zdefiniowanych przez u\u017cytkownika atrybut\u00f3w { 'owner' : 'Kowalski' , '_BankAccount__balance' : 1000 } >>> ba . __class__ . __name__ # Nazwa klasy 'BankAccount' >>> ba . withdraw . __name__ # Nazwa metody 'withdraw' >>> [ attrib for attrib in dir ( ba ) if not attrib . startswith ( '_' )] # Interfejs [ 'counter' , 'deposit' , 'info' , 'owner' , 'withdraw' ] Metody specjalne Klasy umo\u017cliwiaj\u0105 prze\u0142adowywanie operator\u00f3w (podobnie jak w C++). Jest to mo\u017cliwe dzi\u0119ki specjalnym metodom, kt\u00f3re mo\u017cna zaimplementowa\u0107 w klasie. Poni\u017cej przyk\u0142ad klasy Special , w kt\u00f3rej zdefiniowano kilka metod specjalnych. class Special : def __init__ ( self , * args , ** kwargs ): pass # konstruktor def __del__ ( self ): pass # Destruktor \u2013 rzadko wykorzystywany def __str__ ( self ): pass # Reprezentacja znakowa; wywo\u0142ywana przez print i str def __repr__ ( self ): pass # Reprezentacja znakowa; wywo\u0142ywana przez repr # eval(repr(a)) powinno by\u0107 r\u00f3wne a def __getitem__ ( self , i ): pass # Indeksacja dla obiektu: b = a[i] def __setitem__ ( self , i , v ): pass # Przypisanie z wykorzystaniem indeksacji: a[i] = v def __len__ ( self ): pass # Wywo\u0142ywane przez len(a); Funkcja powinna zwr\u00f3ci\u0107 # d\u0142ugo\u015b\u0107 obiektu (o ile ma to uzasadnienie) def __eq__ ( self , x ): pass # Test self == x; zwraca True lub False def __add__ ( self , b ): pass # Definiuje self + b def __sub__ ( self , b ): pass # Definiuje self \u2013 b def __mul__ ( self , b ): pass # Definiuje self * b def __div__ ( self , b ): pass # Definiuje self / b def __pow__ ( self , b ): pass # Definiuje self ** b","title":"Zaawansowana obiektowo\u015b\u0107"},{"location":"zaawansowane_oop.html#zaawansowane-kwestie-oop","text":"","title":"Zaawansowane kwestie OOP"},{"location":"zaawansowane_oop.html#interfejsy-i-introspekcja","text":"Istnieje mo\u017cliwo\u015b\u0107 sprawdzania charakterystyk klas i obiekt\u00f3w w trakcie dzia\u0142ania programu. >>> issubclass ( Pochodna , A ) True >>> issubclass ( B , Pochodna ) False >>> Pochodna . __bases__ ( < class ' __main__ . B '>, <class ' __main__ . A '>) >>> d = Pochodna () >>> isinstance ( d , A ) True >>> hasattr ( d , \"fa\" ) True >>> callable ( getattr ( d , \"fa\" , None )) True","title":"Interfejsy i introspekcja"},{"location":"zaawansowane_oop.html#skadowe-prywatne-klasy","text":"Wszystkie atrybuty i metody zdefiniowane w klasie s\u0105 publiczne. Aby ukry\u0107 atrybut lub metod\u0119 przed dost\u0119pem spoza klasy (sk\u0142adowa private) nale\u017cy jej nazw\u0119 poprzedzi\u0107 dwoma podkre\u015blnikami (np. __atrybut ). class KontoBankowe : def __init__ ( self , nazwa , stan = 0 ): self . nazwa = nazwa self . __stan = stan def info ( self ): print ( \"nazwa:\" , self . nazwa ) print ( \"stan:\" , self . __stan ) def wyplac ( self , ilosc ): self . __stan -= ilosc def wplac ( self , ilosc ): self . __stan += ilosc jk = KontoBankowe ( \"Kowalski\" , 1000 ) print ( jk . stan ) # B\u0142\u0105d! print ( jk . __stan ) # B\u0142\u0105d! print ( jk . _KontoBankowe__stan ) # OK","title":"Sk\u0142adowe prywatne klasy"},{"location":"zaawansowane_oop.html#skadowe-statyczne","text":"Sk\u0142adowe statyczne s\u0105 wsp\u00f3lne dla wszystkich instancji klasy. class CountedObject : __count = 0 # Statyczna skladowa def __init__ ( self ): CountedObject . __count += 1 @staticmethod def staticGetCount (): return CountedObject . __count @classmethod def classGetCount ( cls ): print ( \"classGetCount invoked for instance of\" , cls ) return cls . __count print ( \"Number of objects: %s \" % CountedObject . staticGetCount ()) print ( \"Creating objects...\" ) c1 = CountedObject () c2 = CountedObject () cs = [ CountedObject (), CountedObject ()] print ( \"Number of objects: %s \" % CountedObject . staticGetCount ()) print ( \"Number of objects: %s \" % CountedObject . classGetCount ()) Dzia\u0142anie: Number of objects: 0 Creating objects... Number of objects: 4 classGetCount invoked for instance of <class '__main__.CountedObject'>","title":"Sk\u0142adowe statyczne"},{"location":"zaawansowane_oop.html#wasciwosci","text":"W\u0142a\u015bciwo\u015bci (nie myli\u0107 z atrybutami!), zwane r\u00f3wnie\u017c jako gettery i settery, umo\u017cliwiaj\u0105 enkapsulacj\u0119 obiektu. S\u0105 odpowiednikiem metod dost\u0119powych. class Rectangle : def __init__ ( self ): self . width = 0 self . height = 0 def setSize ( self , size ): self . width , self . height = size def getSize ( self ): return self . width , self . height size = property ( getSize , setSize ) Przyk\u0142ad u\u017cycia: >>> r = Rectangle () >>> r . width = 10 >>> r . height = 20 >>> r . size ( 10 , 20 ) >>> r . size = 150 , 100 >>> r . height 100 Istnieje mo\u017cliwo\u015b\u0107 definiowania w\u0142a\u015bciwo\u015bci typu \"read-only\". Poni\u017cej przyk\u0142ad konta bankowego, w kt\u00f3rym mo\u017cna odczyta\u0107 stan konta, ale nie mo\u017cna go zmieni\u0107. class BankAccount : counter = 0 def __init__ ( self , owner , balance = 0 ): self . owner = owner self . __balance = balance BankAccount . counter += 1 def __getBalance ( self ): return self . __balance balance = property ( __getBalance ) U\u017cycie: >>> ba = BankAccount ( \"jk\" , 100 ) >>> ba . balance 100 >>> ba . balance = 100 # B\u0142\u0105d!","title":"W\u0142a\u015bciwo\u015bci"},{"location":"zaawansowane_oop.html#atrybuty-specjalne","text":"Instancje klas posiadaj\u0105 specjalne atrybuty, kt\u00f3re opisuj\u0105 obiekty. :: >>> ba = BankAccount ( \"Kowalski\" , 1000 ) >>> ba . __dict__ # S\u0142ownik zdefiniowanych przez u\u017cytkownika atrybut\u00f3w { 'owner' : 'Kowalski' , '_BankAccount__balance' : 1000 } >>> ba . __class__ . __name__ # Nazwa klasy 'BankAccount' >>> ba . withdraw . __name__ # Nazwa metody 'withdraw' >>> [ attrib for attrib in dir ( ba ) if not attrib . startswith ( '_' )] # Interfejs [ 'counter' , 'deposit' , 'info' , 'owner' , 'withdraw' ]","title":"Atrybuty specjalne"},{"location":"zaawansowane_oop.html#metody-specjalne","text":"Klasy umo\u017cliwiaj\u0105 prze\u0142adowywanie operator\u00f3w (podobnie jak w C++). Jest to mo\u017cliwe dzi\u0119ki specjalnym metodom, kt\u00f3re mo\u017cna zaimplementowa\u0107 w klasie. Poni\u017cej przyk\u0142ad klasy Special , w kt\u00f3rej zdefiniowano kilka metod specjalnych. class Special : def __init__ ( self , * args , ** kwargs ): pass # konstruktor def __del__ ( self ): pass # Destruktor \u2013 rzadko wykorzystywany def __str__ ( self ): pass # Reprezentacja znakowa; wywo\u0142ywana przez print i str def __repr__ ( self ): pass # Reprezentacja znakowa; wywo\u0142ywana przez repr # eval(repr(a)) powinno by\u0107 r\u00f3wne a def __getitem__ ( self , i ): pass # Indeksacja dla obiektu: b = a[i] def __setitem__ ( self , i , v ): pass # Przypisanie z wykorzystaniem indeksacji: a[i] = v def __len__ ( self ): pass # Wywo\u0142ywane przez len(a); Funkcja powinna zwr\u00f3ci\u0107 # d\u0142ugo\u015b\u0107 obiektu (o ile ma to uzasadnienie) def __eq__ ( self , x ): pass # Test self == x; zwraca True lub False def __add__ ( self , b ): pass # Definiuje self + b def __sub__ ( self , b ): pass # Definiuje self \u2013 b def __mul__ ( self , b ): pass # Definiuje self * b def __div__ ( self , b ): pass # Definiuje self / b def __pow__ ( self , b ): pass # Definiuje self ** b","title":"Metody specjalne"}]}