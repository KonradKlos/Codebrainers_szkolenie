{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Konspekt Programowanie funkcyjne - wybrane elementy Funkcje anonimowe Funkcja filtruj\u0105ca filter , aplikuj\u0105ca map i redukuj\u0105ca reduce Generowanie list, s\u0142ownik\u00f3w i zbior\u00f3w Wyra\u017cenia generatorowe Programowanie obiektowe Co to jest obiekt, co jest obiektem w Pythonie Jakie s\u0105 obiekty w Pythonie Klasy, pola, metody Dziedziczenie Programowanie webowe - framework do wyboru","title":"Wst\u0119p"},{"location":"index.html#konspekt","text":"Programowanie funkcyjne - wybrane elementy Funkcje anonimowe Funkcja filtruj\u0105ca filter , aplikuj\u0105ca map i redukuj\u0105ca reduce Generowanie list, s\u0142ownik\u00f3w i zbior\u00f3w Wyra\u017cenia generatorowe Programowanie obiektowe Co to jest obiekt, co jest obiektem w Pythonie Jakie s\u0105 obiekty w Pythonie Klasy, pola, metody Dziedziczenie Programowanie webowe - framework do wyboru","title":"Konspekt"},{"location":"about.html","text":"Code Brainers Code Brainers Grupa entuzjast\u00f3w oprogramowania, kt\u00f3rzy postanowili podzieli\u0107 si\u0119 swoj\u0105 pasj\u0105 i uczy\u0107 osoby chc\u0105ce zacz\u0105\u0107 przygod\u0119 z programowaniem. Wybrali\u015bmy j\u0119zyk Python poniewa\u017c jest wszechstronny, przejrzysty oraz prosty w nauce. Team Nasz zesp\u00f3\u0142 sk\u0142ada si\u0119 z kilku deweloper\u00f3w oraz szkoleniowc\u00f3w wykorzystuj\u0105cych j\u0119zyk Python w codziennej pracy oraz organizator\u00f3w i przedsi\u0119biorc\u00f3w, kt\u00f3rzy przygotowali ca\u0142o\u015b\u0107 spraw niezwi\u0105zanych z programowaniem. Organizatorzy Oskar Meysztowicz Rafa\u0142 Terkalski Instruktorzy Leszek Tarkowski Piotr Arciszewski Klemens Noga Jakub St\u0119pak Piotr Ociepka Jacek Pytel Marcin Klimek Code Brainers Sp. z o.o. ul. Plac Matejki 5/22, 31-157 Krak\u00f3w (+48) 533-746-706 biuro@codebrainers.pl","title":"About"},{"location":"about.html#code-brainers","text":"Code Brainers Grupa entuzjast\u00f3w oprogramowania, kt\u00f3rzy postanowili podzieli\u0107 si\u0119 swoj\u0105 pasj\u0105 i uczy\u0107 osoby chc\u0105ce zacz\u0105\u0107 przygod\u0119 z programowaniem. Wybrali\u015bmy j\u0119zyk Python poniewa\u017c jest wszechstronny, przejrzysty oraz prosty w nauce.","title":"Code Brainers"},{"location":"about.html#team","text":"Nasz zesp\u00f3\u0142 sk\u0142ada si\u0119 z kilku deweloper\u00f3w oraz szkoleniowc\u00f3w wykorzystuj\u0105cych j\u0119zyk Python w codziennej pracy oraz organizator\u00f3w i przedsi\u0119biorc\u00f3w, kt\u00f3rzy przygotowali ca\u0142o\u015b\u0107 spraw niezwi\u0105zanych z programowaniem.","title":"Team"},{"location":"about.html#organizatorzy","text":"Oskar Meysztowicz Rafa\u0142 Terkalski","title":"Organizatorzy"},{"location":"about.html#instruktorzy","text":"Leszek Tarkowski Piotr Arciszewski Klemens Noga Jakub St\u0119pak Piotr Ociepka Jacek Pytel Marcin Klimek Code Brainers Sp. z o.o. ul. Plac Matejki 5/22, 31-157 Krak\u00f3w (+48) 533-746-706 biuro@codebrainers.pl","title":"Instruktorzy"},{"location":"dziedziczenie.html","text":"Dziedziczenie Dziedziczenie \u2013 umo\u017cliwia tworzenie nowych klas, kt\u00f3re przejmuj\u0105 form\u0119 i funkcjonalno\u015b\u0107 klas bazowych. Dziedziczenie definiowane jest za pomoc\u0105 sk\u0142adni: class Base : pass class Derived ( Base ): pass Przyk\u0142ad: class CheckedAccount ( BankAccount ): def __init__ ( self , owner , balance = 0 , limit = 0 ): BankAccount . __init__ ( self , owner , balance ) self . limit = limit def withdraw ( self , amount ): if ( self . balance - amount ) < - self . limit : print ( \"Brak srodkow na koncie\" ) else : BankAccount . withdraw ( self , amount ) Aby wywo\u0142a\u0107 konstruktor klasy bazowej mo\u017cna u\u017cy\u0107 metody super() zwracaj\u0105cej objekt proxy rodzica. def __init__ ( self , owner , balance = 0 , limit = 0 ): super () . __init__ ( owner , balance ) self . limit = limit Wielokrotne dziedziczenie Dziedziczenie wielokrotne \u2013 klasy mog\u0105 dziedziczy\u0107 po kilku klasach bazowych. class Base1 ( object ): def __init__ ( self ): super () . __init__ () self . a = \"Base1.a\" def fa ( self ): print \"a:\" , self . a class Base2 ( object ): def __init__ ( self ): super () . __init__ () self . b = \"Base2.b\" def fb ( self ): print \"b:\" , self . b class Derived ( Base2 , Base1 ): def __init__ ( self ): super () . __init__ () :: >>> d = Derived () >>> d . a 'Base1.a' >>> d . b 'Base2.a' >>> d . fa () a : Base1 . a >>> d . fb () b : Base2 . b Interfejsy i introspekcja Istnieje mo\u017cliwo\u015b\u0107 sprawdzania charakterystyk klas i obiekt\u00f3w w trakcie dzia\u0142ania programu. >>> issubclass ( Derived , Base1 ) True >>> issubclass ( Base2 , Derived ) False >>> Derived . __bases__ ( < class ' __main__ . Base2 '>, <class ' __main__ . Base1 '>) >>> d = Derived () >>> isinstance ( d , Base1 ) True >>> hasattr ( d , \"fa\" ) True >>> callable ( getattr ( d , \"fa\" , None )) True","title":"Dziedziczenie"},{"location":"dziedziczenie.html#dziedziczenie","text":"Dziedziczenie \u2013 umo\u017cliwia tworzenie nowych klas, kt\u00f3re przejmuj\u0105 form\u0119 i funkcjonalno\u015b\u0107 klas bazowych. Dziedziczenie definiowane jest za pomoc\u0105 sk\u0142adni: class Base : pass class Derived ( Base ): pass Przyk\u0142ad: class CheckedAccount ( BankAccount ): def __init__ ( self , owner , balance = 0 , limit = 0 ): BankAccount . __init__ ( self , owner , balance ) self . limit = limit def withdraw ( self , amount ): if ( self . balance - amount ) < - self . limit : print ( \"Brak srodkow na koncie\" ) else : BankAccount . withdraw ( self , amount ) Aby wywo\u0142a\u0107 konstruktor klasy bazowej mo\u017cna u\u017cy\u0107 metody super() zwracaj\u0105cej objekt proxy rodzica. def __init__ ( self , owner , balance = 0 , limit = 0 ): super () . __init__ ( owner , balance ) self . limit = limit","title":"Dziedziczenie"},{"location":"dziedziczenie.html#wielokrotne-dziedziczenie","text":"Dziedziczenie wielokrotne \u2013 klasy mog\u0105 dziedziczy\u0107 po kilku klasach bazowych. class Base1 ( object ): def __init__ ( self ): super () . __init__ () self . a = \"Base1.a\" def fa ( self ): print \"a:\" , self . a class Base2 ( object ): def __init__ ( self ): super () . __init__ () self . b = \"Base2.b\" def fb ( self ): print \"b:\" , self . b class Derived ( Base2 , Base1 ): def __init__ ( self ): super () . __init__ () :: >>> d = Derived () >>> d . a 'Base1.a' >>> d . b 'Base2.a' >>> d . fa () a : Base1 . a >>> d . fb () b : Base2 . b","title":"Wielokrotne dziedziczenie"},{"location":"dziedziczenie.html#interfejsy-i-introspekcja","text":"Istnieje mo\u017cliwo\u015b\u0107 sprawdzania charakterystyk klas i obiekt\u00f3w w trakcie dzia\u0142ania programu. >>> issubclass ( Derived , Base1 ) True >>> issubclass ( Base2 , Derived ) False >>> Derived . __bases__ ( < class ' __main__ . Base2 '>, <class ' __main__ . Base1 '>) >>> d = Derived () >>> isinstance ( d , Base1 ) True >>> hasattr ( d , \"fa\" ) True >>> callable ( getattr ( d , \"fa\" , None )) True","title":"Interfejsy i introspekcja"},{"location":"iteratory.html","text":"Iteratory Obiekty iterowalne posiadaj\u0105 metod\u0119 __iter__ zwracaj\u0105c\u0105 obiekt iteratora Iterator posiada metod\u0119 __next()__ , kt\u00f3ra zwraca kolejny element z iterowanej sekwencji Je\u015bli iteracja dobieg\u0142a ko\u0144ca (brak kolejnych element\u00f3w) zg\u0142aszany jest wyj\u0105tek StopIteration Iterator jest zwracany przez funkcj\u0119 iter() >>> s = 'ab' >>> it = iter ( s ) >>> it . __next__ () 'a' >>> it . __next__ () 'b' >>> it . __next__ () Traceback ( most recent call last ): StopIteration Przyk\u0142ad:: class Fibs : def __init__ ( self , limit ): self . a = 0 self . b = 1 self . limit = limit def __next__ ( self ): self . a , self . b = self . b , self . a + self . b if self . a > self . limit : raise StopIteration return self . a def __iter__ ( self ): return self :: >>> list ( Fibs ( 100 )) [ 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ] Generatory Generatory s\u0105 iteratorami definiowanymi przy pomocy sk\u0142adni normalnej funkcji. Instrukcja yield zwraca kolejn\u0105 warto\u015b\u0107 z funkcji generatora. :: def reverse ( data ): for index in range ( len ( data ) - 1 , - 1 , - 1 ): yield data [ index ] :: >>> for char in reverse ( 'golf' ): ... print ( char ) f l o g","title":"Iteratory"},{"location":"iteratory.html#iteratory","text":"Obiekty iterowalne posiadaj\u0105 metod\u0119 __iter__ zwracaj\u0105c\u0105 obiekt iteratora Iterator posiada metod\u0119 __next()__ , kt\u00f3ra zwraca kolejny element z iterowanej sekwencji Je\u015bli iteracja dobieg\u0142a ko\u0144ca (brak kolejnych element\u00f3w) zg\u0142aszany jest wyj\u0105tek StopIteration Iterator jest zwracany przez funkcj\u0119 iter() >>> s = 'ab' >>> it = iter ( s ) >>> it . __next__ () 'a' >>> it . __next__ () 'b' >>> it . __next__ () Traceback ( most recent call last ): StopIteration Przyk\u0142ad:: class Fibs : def __init__ ( self , limit ): self . a = 0 self . b = 1 self . limit = limit def __next__ ( self ): self . a , self . b = self . b , self . a + self . b if self . a > self . limit : raise StopIteration return self . a def __iter__ ( self ): return self :: >>> list ( Fibs ( 100 )) [ 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ]","title":"Iteratory"},{"location":"iteratory.html#generatory","text":"Generatory s\u0105 iteratorami definiowanymi przy pomocy sk\u0142adni normalnej funkcji. Instrukcja yield zwraca kolejn\u0105 warto\u015b\u0107 z funkcji generatora. :: def reverse ( data ): for index in range ( len ( data ) - 1 , - 1 , - 1 ): yield data [ index ] :: >>> for char in reverse ( 'golf' ): ... print ( char ) f l o g","title":"Generatory"},{"location":"klasy.html","text":"Klasy Klasy s\u0105 zbiorami atrybut\u00f3w oraz metod. Klasy umo\u017cliwiaj\u0105: * Tworzenie nowych typ\u00f3w danych definiowanych przez u\u017cytkownika * Rozszerzanie mo\u017cliwo\u015bci istniej\u0105cych typ\u00f3w danych Definicja klasy class BankAccount : def __init__ ( self , owner , balance = 0 ): self . owner = owner self . balance = balance def withdraw ( self , amount ): self . balance -= amount def deposit ( self , amount ): self . balance += amount def info ( self ): print ( \"owner:\" , self . owner , \"; balance:\" , self . balance ) Tworzenie obiekt\u00f3w Aby utworzy\u0107 obiekt danej klasy nale\u017cy wywo\u0142a\u0107 klas\u0119 przy pomocy operatora (). Przyk\u0142ad: jk = BankAccount ( \"Jan Kowalski\" , 1000 ) jk . info () jk . deposit ( 2000 ) jk . withdraw ( 2500 ) jk . info () jk . balance = 0 # Dost\u0119p do sk\u0142adowej balance jk . info () :: owner : Jan Kowalski ; balance : 1000 owner : Jan Kowalski ; balance : 500 owner : Jan Kowalski ; balance : 0 Sk\u0142adowe prywatne klasy Wszystkie atrybuty i metody zdefiniowane w klasie s\u0105 publiczne. Aby ukry\u0107 atrybut lub metod\u0119 przed dost\u0119pem spoza klasy (sk\u0142adowa private) nale\u017cy jej nazw\u0119 poprzedzi\u0107 dwoma podkre\u015blnikami (np. __atrybut ). class BankAccount : def __init__ ( self , owner , balance = 0 ): self . owner = owner self . __balance = balance def withdraw ( self , amount ): self . __balance -= amount def deposit ( self , amount ): self . __balance += amount def info ( self ): print \"owner:\" , self . owner , \"; balance:\" , self . __balance jk = BankAccount ( \"Kowalski\" , 1000 ) print ( jk . balance ) # B\u0142\u0105d! print ( jk . _BankAccount__balance ) # OK \u2003 Sk\u0142adowe statyczne Sk\u0142adowe statyczne s\u0105 wsp\u00f3lne dla wszystkich instancji klasy. class CountedObject : __count = 0 # Statyczna skladowa def __init__ ( self ): CountedObject . __count += 1 @staticmethod def staticGetCount (): return CountedObject . __count @classmethod def classGetCount ( cls ): print \"classGetCount invoked for instance of\" , cls return cls . __count print \"Number of objects: %s \" % CountedObject . staticGetCount () print \"Creating objects...\" c1 = CountedObject () c2 = CountedObject () cs = [ CountedObject (), CountedObject ()] print \"Number of objects: %s \" % CountedObject . staticGetCount () print \"Number of objects: %s \" % CountedObject . classGetCount () :: Number of objects : 0 Creating objects ... Number of objects : 4 classGetCount invoked for instance of < class ' __main__ . CountedObject '> W\u0142a\u015bciwo\u015bci W\u0142a\u015bciwo\u015bci umo\u017cliwiaj\u0105 enkapsulacj\u0119 obiektu. S\u0105 odpowiednikiem metod dost\u0119powych. class Rectangle : def __init__ ( self ): self . width = 0 self . height = 0 def setSize ( self , size ): self . width , self . height = size def getSize ( self ): return self . width , self . height size = property ( getSize , setSize ) :: >>> r = Rectangle () >>> r . width = 10 >>> r . height = 20 >>> r . size ( 10 , 20 ) >>> r . size = 150 , 100 >>> r . height 100 Istnieje mo\u017cliwo\u015b\u0107 definiowania w\u0142a\u015bciwo\u015bci typu \"read-only\". class BankAccount : counter = 0 def __init__ ( self , owner , balance = 0 ): self . owner = owner self . __balance = balance BankAccount . counter += 1 def __getBalance ( self ): return self . __balance balance = property ( __getBalance ) :: >>> ba = BankAccount ( \"jk\" , 100 ) >>> ba . balance 100 >>> ba . balance = 100 # B\u0142\u0105d! \u2003 Atrybuty specjalne Instancje klas posiadaj\u0105 specjalne atrybuty, kt\u00f3re opisuj\u0105 obiekty. :: >>> ba = BankAccount ( \"Kowalski\" , 1000 ) >>> ba . __dict__ # S\u0142ownik zdefiniowanych przez u\u017cytkownika atrybut\u00f3w { 'owner' : 'Kowalski' , '_BankAccount__balance' : 1000 } >>> ba . __class__ . __name__ # Nazwa klasy 'BankAccount' >>> ba . withdraw . __name__ # Nazwa metody 'withdraw' >>> [ attrib for attrib in dir ( ba ) if not attrib . startswith ( '_' )] # Interfejs [ 'counter' , 'deposit' , 'info' , 'owner' , 'withdraw' ] Metody specjalne Klasy umo\u017cliwiaj\u0105 prze\u0142adowywanie operator\u00f3w (podobnie jak w C++). Jest to mo\u017cliwe dzi\u0119ki specjalnym metodom, kt\u00f3re mo\u017cna zaimplementowa\u0107 w klasie. class Special : def __init__ ( self , * args , ** kwargs ): pass # konstruktor def __del__ ( self ): pass # Destruktor \u2013 rzadko wykorzystywany def __str__ ( self ): pass # Reprezentacja znakowa; wywo\u0142ywana przez print i str def __repr__ ( self ): pass # Reprezentacja znakowa; wywo\u0142ywana przez repr # eval(repr(a)) powinno by\u0107 r\u00f3wne a def __getitem__ ( self , i ): pass # Indeksacja dla obiektu: b = a[i] def __setitem__ ( self , i , v ): pass # Przypisanie z wykorzystaniem indeksacji: a[i] = v def __len__ ( self ): pass # Wywo\u0142ywane przez len(a); Funkcja powinna zwr\u00f3ci\u0107 # d\u0142ugo\u015b\u0107 obiektu (o ile ma to uzasadnienie) def __eq__ ( self , x ): pass # Test self == x; zwraca True lub False def __add__ ( self , b ): pass # Definiuje self + b def __sub__ ( self , b ): pass # Definiuje self \u2013 b def __mul__ ( self , b ): pass # Definiuje self * b def __div__ ( self , b ): pass # Definiuje self / b def __pow__ ( self , b ): pass # Definiuje self ** b","title":"Klasy"},{"location":"klasy.html#klasy","text":"Klasy s\u0105 zbiorami atrybut\u00f3w oraz metod. Klasy umo\u017cliwiaj\u0105: * Tworzenie nowych typ\u00f3w danych definiowanych przez u\u017cytkownika * Rozszerzanie mo\u017cliwo\u015bci istniej\u0105cych typ\u00f3w danych","title":"Klasy"},{"location":"klasy.html#definicja-klasy","text":"class BankAccount : def __init__ ( self , owner , balance = 0 ): self . owner = owner self . balance = balance def withdraw ( self , amount ): self . balance -= amount def deposit ( self , amount ): self . balance += amount def info ( self ): print ( \"owner:\" , self . owner , \"; balance:\" , self . balance )","title":"Definicja klasy"},{"location":"klasy.html#tworzenie-obiektow","text":"Aby utworzy\u0107 obiekt danej klasy nale\u017cy wywo\u0142a\u0107 klas\u0119 przy pomocy operatora (). Przyk\u0142ad: jk = BankAccount ( \"Jan Kowalski\" , 1000 ) jk . info () jk . deposit ( 2000 ) jk . withdraw ( 2500 ) jk . info () jk . balance = 0 # Dost\u0119p do sk\u0142adowej balance jk . info () :: owner : Jan Kowalski ; balance : 1000 owner : Jan Kowalski ; balance : 500 owner : Jan Kowalski ; balance : 0","title":"Tworzenie obiekt\u00f3w"},{"location":"klasy.html#skadowe-prywatne-klasy","text":"Wszystkie atrybuty i metody zdefiniowane w klasie s\u0105 publiczne. Aby ukry\u0107 atrybut lub metod\u0119 przed dost\u0119pem spoza klasy (sk\u0142adowa private) nale\u017cy jej nazw\u0119 poprzedzi\u0107 dwoma podkre\u015blnikami (np. __atrybut ). class BankAccount : def __init__ ( self , owner , balance = 0 ): self . owner = owner self . __balance = balance def withdraw ( self , amount ): self . __balance -= amount def deposit ( self , amount ): self . __balance += amount def info ( self ): print \"owner:\" , self . owner , \"; balance:\" , self . __balance jk = BankAccount ( \"Kowalski\" , 1000 ) print ( jk . balance ) # B\u0142\u0105d! print ( jk . _BankAccount__balance ) # OK","title":"Sk\u0142adowe prywatne klasy"},{"location":"klasy.html#skadowe-statyczne","text":"Sk\u0142adowe statyczne s\u0105 wsp\u00f3lne dla wszystkich instancji klasy. class CountedObject : __count = 0 # Statyczna skladowa def __init__ ( self ): CountedObject . __count += 1 @staticmethod def staticGetCount (): return CountedObject . __count @classmethod def classGetCount ( cls ): print \"classGetCount invoked for instance of\" , cls return cls . __count print \"Number of objects: %s \" % CountedObject . staticGetCount () print \"Creating objects...\" c1 = CountedObject () c2 = CountedObject () cs = [ CountedObject (), CountedObject ()] print \"Number of objects: %s \" % CountedObject . staticGetCount () print \"Number of objects: %s \" % CountedObject . classGetCount () :: Number of objects : 0 Creating objects ... Number of objects : 4 classGetCount invoked for instance of < class ' __main__ . CountedObject '>","title":"Sk\u0142adowe statyczne"},{"location":"klasy.html#wasciwosci","text":"W\u0142a\u015bciwo\u015bci umo\u017cliwiaj\u0105 enkapsulacj\u0119 obiektu. S\u0105 odpowiednikiem metod dost\u0119powych. class Rectangle : def __init__ ( self ): self . width = 0 self . height = 0 def setSize ( self , size ): self . width , self . height = size def getSize ( self ): return self . width , self . height size = property ( getSize , setSize ) :: >>> r = Rectangle () >>> r . width = 10 >>> r . height = 20 >>> r . size ( 10 , 20 ) >>> r . size = 150 , 100 >>> r . height 100 Istnieje mo\u017cliwo\u015b\u0107 definiowania w\u0142a\u015bciwo\u015bci typu \"read-only\". class BankAccount : counter = 0 def __init__ ( self , owner , balance = 0 ): self . owner = owner self . __balance = balance BankAccount . counter += 1 def __getBalance ( self ): return self . __balance balance = property ( __getBalance ) :: >>> ba = BankAccount ( \"jk\" , 100 ) >>> ba . balance 100 >>> ba . balance = 100 # B\u0142\u0105d!","title":"W\u0142a\u015bciwo\u015bci"},{"location":"klasy.html#atrybuty-specjalne","text":"Instancje klas posiadaj\u0105 specjalne atrybuty, kt\u00f3re opisuj\u0105 obiekty. :: >>> ba = BankAccount ( \"Kowalski\" , 1000 ) >>> ba . __dict__ # S\u0142ownik zdefiniowanych przez u\u017cytkownika atrybut\u00f3w { 'owner' : 'Kowalski' , '_BankAccount__balance' : 1000 } >>> ba . __class__ . __name__ # Nazwa klasy 'BankAccount' >>> ba . withdraw . __name__ # Nazwa metody 'withdraw' >>> [ attrib for attrib in dir ( ba ) if not attrib . startswith ( '_' )] # Interfejs [ 'counter' , 'deposit' , 'info' , 'owner' , 'withdraw' ]","title":"Atrybuty specjalne"},{"location":"klasy.html#metody-specjalne","text":"Klasy umo\u017cliwiaj\u0105 prze\u0142adowywanie operator\u00f3w (podobnie jak w C++). Jest to mo\u017cliwe dzi\u0119ki specjalnym metodom, kt\u00f3re mo\u017cna zaimplementowa\u0107 w klasie. class Special : def __init__ ( self , * args , ** kwargs ): pass # konstruktor def __del__ ( self ): pass # Destruktor \u2013 rzadko wykorzystywany def __str__ ( self ): pass # Reprezentacja znakowa; wywo\u0142ywana przez print i str def __repr__ ( self ): pass # Reprezentacja znakowa; wywo\u0142ywana przez repr # eval(repr(a)) powinno by\u0107 r\u00f3wne a def __getitem__ ( self , i ): pass # Indeksacja dla obiektu: b = a[i] def __setitem__ ( self , i , v ): pass # Przypisanie z wykorzystaniem indeksacji: a[i] = v def __len__ ( self ): pass # Wywo\u0142ywane przez len(a); Funkcja powinna zwr\u00f3ci\u0107 # d\u0142ugo\u015b\u0107 obiektu (o ile ma to uzasadnienie) def __eq__ ( self , x ): pass # Test self == x; zwraca True lub False def __add__ ( self , b ): pass # Definiuje self + b def __sub__ ( self , b ): pass # Definiuje self \u2013 b def __mul__ ( self , b ): pass # Definiuje self * b def __div__ ( self , b ): pass # Definiuje self / b def __pow__ ( self , b ): pass # Definiuje self ** b","title":"Metody specjalne"},{"location":"obiekty.html","text":"Wszystko jest obiektem W Pythonie wszystko jest obiektem, a tym samym posiada pewien wsp\u00f3lny zestaw cech: To\u017csamo\u015b\u0107 (identity) \u2013 wskazuje na lokalizacj\u0119 obiektu w pami\u0119ci Typ (type) \u2013 opisuje reprezentacj\u0119 obiektu dla Pythona Warto\u015b\u0107 (value) \u2013 dane przechowywane w obiekcie >>> lst = [ 1 , 2 , 3 ] >>> id ( lst ) 30098576 >>> type ( lst ) < type 'list' > >>> lst [ 1 , 2 , 3 ] Po utworzeniu obiektu jego to\u017csamo\u015b\u0107 i typ nie mog\u0105 by\u0107 zmienione. Je\u015bli warto\u015b\u0107 obiektu si\u0119 zmienia, jest to obiekt zmienny (mutable) . Je\u015bli nie mo\u017ce ulec zmianie \u2013 obiekt niezmienny (immutable) . Na przyk\u0142ad, typy str i tuple s\u0105 niezmienne. >>> t = ( 1 , 2 , 3 ) >>> t [ 0 ] = 2 Traceback ( most recent call last ): t [ 0 ] = 2 TypeError : 'tuple' object does not support item assignment Niekt\u00f3re obiekty posiadaj\u0105: Atrybuty \u2013 warto\u015bci powi\u0105zane z obiektem Metody \u2013 wywo\u0142ywalne funkcje, kt\u00f3re operuj\u0105 na obiekcie Dost\u0119p do atrybut\u00f3w i metod uzyskuje si\u0119 poprzez wykorzystanie sk\u0142adni z kropkami (.) >>> f = open ( r \"c: \\\\ Training \\\\ test.txt\" , \"w\" ) >>> print f . closed False >>> f . close () >>> print f . closed True","title":"Obiekty"},{"location":"obiekty.html#wszystko-jest-obiektem","text":"W Pythonie wszystko jest obiektem, a tym samym posiada pewien wsp\u00f3lny zestaw cech: To\u017csamo\u015b\u0107 (identity) \u2013 wskazuje na lokalizacj\u0119 obiektu w pami\u0119ci Typ (type) \u2013 opisuje reprezentacj\u0119 obiektu dla Pythona Warto\u015b\u0107 (value) \u2013 dane przechowywane w obiekcie >>> lst = [ 1 , 2 , 3 ] >>> id ( lst ) 30098576 >>> type ( lst ) < type 'list' > >>> lst [ 1 , 2 , 3 ] Po utworzeniu obiektu jego to\u017csamo\u015b\u0107 i typ nie mog\u0105 by\u0107 zmienione. Je\u015bli warto\u015b\u0107 obiektu si\u0119 zmienia, jest to obiekt zmienny (mutable) . Je\u015bli nie mo\u017ce ulec zmianie \u2013 obiekt niezmienny (immutable) . Na przyk\u0142ad, typy str i tuple s\u0105 niezmienne. >>> t = ( 1 , 2 , 3 ) >>> t [ 0 ] = 2 Traceback ( most recent call last ): t [ 0 ] = 2 TypeError : 'tuple' object does not support item assignment Niekt\u00f3re obiekty posiadaj\u0105: Atrybuty \u2013 warto\u015bci powi\u0105zane z obiektem Metody \u2013 wywo\u0142ywalne funkcje, kt\u00f3re operuj\u0105 na obiekcie Dost\u0119p do atrybut\u00f3w i metod uzyskuje si\u0119 poprzez wykorzystanie sk\u0142adni z kropkami (.) >>> f = open ( r \"c: \\\\ Training \\\\ test.txt\" , \"w\" ) >>> print f . closed False >>> f . close () >>> print f . closed True","title":"Wszystko jest obiektem"},{"location":"programowanie_funkcyjne.html","text":"Funkcje anonimowe (lambda) Python umo\u017cliwia tworzenie funkcji w miejscu, bez osobnego deklarowania ich. Takie funkcje nazywane s\u0105 \"anonimowe\", bo nie musz\u0105 przyjmowa\u0107 nazw, a wykorzystuje si\u0119 je cz\u0119sto jako np. argumenty do \"normalnych\" funkcji. Podstawowa sk\u0142adania funkcji anonimowej jest nast\u0119puj\u0105ca: lambda arg1, arg2: arg1 ** arg2 \\--------/ \\----------/ argumenty operacja, kt\u00f3rej wynik jest zwracany przez funkcj\u0119 Podobie\u0144stwo do Excela Operacja funkcji lambda jest niemal identyczna jak zawarto\u015b\u0107 funkcji w kom\u00f3rce w Excelu. R\u00f3\u017cnic\u0105 jest jedynie odwo\u0142ywanie do zmiennych (Python) i nazw kom\u00f3rek (Excel). Przyk\u0142ad funkcji anonimowej obliczaj\u0105cej przeciwprostok\u0105tn\u0105 w tr\u00f3jk\u0105cie prostok\u0105tnym (twierdzenie Pitagorasa): lambda a , b : (( a * a ) + ( b * b )) ** 0.5 Przypomnienie Twierdzenie Pitagorasa: c*c = a*a + b*b . Operator ** to podnoszenie do pot\u0119gi. Je\u015bli wyk\u0142adnik pot\u0119gi ma posta\u0107 1/n (w powy\u017cszym przyk\u0142adzie: 1/2 ), to takie pot\u0119gowanie zamienia si\u0119 w pierwiastkowanie o stopniu n . Funkcje anonimowe s\u0105 obiektami w Pythonie i dzi\u0119ki temu mo\u017cemy je przypisa\u0107 w taki sam spos\u00f3b, jak przypisanie warto\u015bci do zmiennej: pitagoras = lambda a , b : (( a * a ) + ( b * b )) ** 0.5 Pozwala to w dalszym kodzie np. wywo\u0142ywa\u0107 tak\u0105 funkcj\u0119 anonimow\u0105 po jej, de facto, nazwie: >>> pitagoras = lambda a , b : (( a * a ) + ( b * b )) ** 0.5 >>> pitagoras ( 3 , 4 ) 5.0 Zadanie 1 Napisz funkcj\u0119 anonimow\u0105 obliczaj\u0105c\u0105 kwadrat danej warto\u015bci. Czy potrafisz wyt\u0142umaczy\u0107 czym si\u0119 to r\u00f3\u017cni od wykorzystania funkcji pow(a, b) lub operatora a ** b ? Zadanie 2 Napisz funkcj\u0119 anonimow\u0105 obliczaj\u0105c\u0105 \u015bredni\u0105 arytmetyczn\u0105 dw\u00f3ch warto\u015bci. Zadanie 3 Napisz funkcj\u0119 anonimow\u0105 sprawdzaj\u0105c\u0105 czy dana warto\u015b\u0107 jest wi\u0119ksza (lub mniejsza) od pewnej warto\u015bci. Taka funkcja anonimowa powinna zwraca\u0107 warto\u015b\u0107 logiczn\u0105. Filtrowanie, aplikowanie, redukowanie W Pythonie istnieje kilka przydatnych funkcji wykorzystuj\u0105cych funkcje anonimowe i pracuj\u0105cych na zbiorach danych: filter(funkcja, iterator) : zwraca tylko te warto\u015bci ze zbioru danych, dla kt\u00f3rych funkcja(warto\u015b\u0107) zwr\u00f3ci\u0142a True . map(funkcja, iterator) : aplikuje funkcj\u0119 dla ka\u017cdej warto\u015bci. reduce(funkcja, iterator) : s\u0142u\u017cy do zredukowania ca\u0142ego zbioru danych do jednej warto\u015bci. Filtrowanie Dla przyk\u0142ad\u00f3w u\u017cyj\u0119 prostego zbioru danych temperatury: >>> temperatury = [ 37.6, 35.8, 37.6, 33.4, 34.1, 37.1, 35.9, 34.1, 37.1, 40.5, 38.5, 37.6, 35.8, 34.5, 36.4, 38.3, 37.5, 37.7, 34.0, 35.3, 35.7, 38.9, 34.8, 34.1, 39.6, 35.4, 34.7, 37.6, 38.4, 36.4, 39.8, 39.1, 37.1, 35.6, 36.8, 37.6, 36.7, 40.0, 38.0, 34.1, 35.5, 38.5, 36.1, 32.6, 32.9, 34.5, 41.0, 38.3, 33.7, 38.7, 36.9, 36.2, 33.7, 38.3, 35.3, 38.3, 40.1, 39.3, 38.2, 37.6, 39.1, 37.1, 34.4, 38.7, 35.8, 38.2, 38.2, 33.1, 37.8, 36.5, 37.6, 37.4, 34.3, 37.7, 36.0, 37.5, 37.6, 36.5, 31.3, 37.7, 40.3, 39.5, 35.7, 38.1, 34.7, 36.5, 34.3, 38.0, 37.0, 38.5, 39.4, 37.6, 41.7, 40.0, 38.4, 38.9, 34.2, 40.2, 34.3, 35.3 ] U\u017cyjmy teraz funkcji filtruj\u0105cej, \u017ceby znale\u017a\u0107 wszystkie warto\u015bci wi\u0119ksze lub r\u00f3wne 40.0 : >>> list ( filter ( lambda x : x >= 40.0 , temperatury )) [40.5, 40.0, 41.0, 40.1, 40.3, 41.7, 40.0, 40.2] Zadanie 4 Znajd\u017a wszystkie warto\u015bci mniejsze od 36.6 . Zadanie 5 Odfiltruj wszystkie warto\u015bci, kt\u00f3re s\u0105 mniejsze b\u0105d\u017a r\u00f3wne 35 lub wi\u0119ksze b\u0105d\u017a r\u00f3wne 40. Aplikowanie Zacznijmy od znalezienia \u015bredniej warto\u015bci temperatury: >>> from statistics import mean >>> sr_temp = mean ( temperatury ) >>> sr_temp 36.9 Teraz mo\u017cna \u0142atwo obliczy\u0107 warto\u015bci odchylenia od \u015bredniej zbioru - przydatne w statystyce: >>> list ( map ( lambda x : x - sr_temp , temperatury )) [0.7, -1.1, 0.7, -3.5, -2.8, 0.2, -1.0, -2.8, 0.2, 3.6, 1.6, 0.7, -1.1, -2.4, -0.5, 1.4, 0.6, 0.8, -2.9, -1.6, -1.2, 2.0, -2.1, -2.8, 2.7, -1.5, -2.2, 0.7, 1.5, -0.5, 2.9, 2.2, 0.2, -1.3, -0.1, 0.7, -0.2, 3.1, 1.1, -2.8, -1.4, 1.6, -0.8, -4.3, -4.0, -2.4, 4.1, 1.4, -3.2, 1.8, 0.0, -0.7, -3.2, 1.4, -1.6, 1.4, 3.2, 2.4, 1.3, 0.7, 2.2, 0.2, -2.5, 1.8, -1.1, 1.3, 1.3, -3.8, 0.9, -0.4, 0.7, 0.5, -2.6, 0.8, -0.9, 0.6, 0.7, -0.4, -5.6, 0.8, 3.4, 2.6, -1.2, 1.2, -2.2, -0.4, -2.6, 1.1, 0.1, 1.6, 2.5, 0.7, 4.8, 3.1, 1.5, 2.0, -2.7, 3.3, -2.6, -1.6] Format liczb zmiennoprzecinkowych Podczas test\u00f3w powy\u017cszego kodu, Python potrafi\u0142 zamiast warto\u015bci 0.7 zwr\u00f3ci\u0107 0.7000000000000028 , dlatego dla uproszczonego zapisu wszystkie warto\u015bci zosta\u0142y zaokr\u0105glone do jednego miejsca po przecinku. Zadanie 6 Oblicz dla ka\u017cdej liczby w zbiorze temperatur kwadrat r\u00f3\u017cnicy tej liczby i \u015bredniej arytmetycznej ca\u0142ego zbioru. Redukowanie Funkcja reduce z modu\u0142u functools pomaga w iteratywnym redukowaniu zbioru warto\u015bci do jednej warto\u015bci. \u017beby to lepiej zobrazowa\u0107, poka\u017c\u0119 dwa przyk\u0142ady u\u017cycia reduce do obliczenia sumy warto\u015bci i ich iloczynu. Przyk\u0142ad 1: obliczenie sumy >>> from functools import reduce >>> reduce ( lambda a , b : a + b , [ 1 , 2 , 3 , 4 , 5 ]) 15 Wykorzystanie funkcji reduce w powy\u017cszym przyk\u0142adzie sprowadza si\u0119 tak naprawd\u0119 do: ((((1 + 2) + 3) + 4) + 5) Przyk\u0142ad 2: obliczenie iloczynu >>> reduce ( lambda a , b : a * b , [ 1 , 2 , 3 , 4 ]) 24 Sprowadza si\u0119 to do: (((1 * 2) * 3) * 4) . Zadanie 7 Maj\u0105c obliczone warto\u015bci odchyle\u0144 temperatur od \u015bredniej temperatury, oblicz wariancj\u0119 tych warto\u015bci. Nie zapomnij o podzieleniu przez ilo\u015b\u0107 element\u00f3w w zbiorze! Tworzenie zbior\u00f3w danych w locie Tworzenie list - list comprehension Dzi\u0119ki generowaniu list w locie mo\u017cemy nawet do\u015b\u0107 skomplikowane p\u0119tle zamieni\u0107 na pojedyncze linijki kodu. Przyk\u0142adowo 4 linijki kodu generuj\u0105ce list\u0119 sze\u015bcian\u00f3w. szesciany = [] for x in range ( 10 ): szesciany . append ( x ** 3 ) W podstawowej wersji mo\u017cemy \"przenie\u015b\u0107\" p\u0119tl\u0119 do nawias\u00f3w kwadratowych: szesciany = [ x ** 3 for x in range ( 10 )] Og\u00f3lniejsza posta\u0107 list comprehension : nowa_lista = [ funkcja ( element ) for element in lista if warunek ( element )] Na przyk\u0142ad by przygotowa\u0107 list\u0119 kwadrat\u00f3w liczb nieparzystych z zakresu od 1 do 100: kwadraty = [ el ** 2 for el in range ( 1 , 101 ) if el % 2 == 0 ] Zadanie 1 Napisz pogram, kt\u00f3ry policzy kwadraty liczb z zakresu [1,10000], kt\u00f3re podzielne s\u0105 przez 5 lub 9. Nast\u0119pnie sprawd\u017a, kt\u00f3re z uzyskanych liczb s\u0105 podzielne zar\u00f3wno przez 5 jak i przez 9. Tworzenie zbior\u00f3w W podobny spos\u00f3b mo\u017cna te\u017c przygotowa\u0107 zbi\u00f3r. zbior = { znak for znak in \"abracadabra\" if znak not in \"abc\" } Zadanie 2 Stw\u00f3rz zbi\u00f3r, kt\u00f3ry wype\u0142nisz 30 wywo\u0142aniami funkcji random.randint(1, 30) . Ile razy wylosowana zosta\u0142a ta sama warto\u015b\u0107? (Sprawdzisz to por\u00f3wnuj\u0105c ilo\u015b\u0107 element\u00f3w zbioru). Jak si\u0119 zachowa program, je\u015bli zmienisz argumenty do funkcji randint ? A je\u015bli zmienisz ilo\u015b\u0107 wywo\u0142a\u0144 tej funkcji? Tworzenie s\u0142ownik\u00f3w Podobnie mo\u017cna stworzy\u0107 s\u0142ownik: tekst = \"abracadabra\" wystapienia = { znak : tekst . count ( znak ) for znak in tekst } Wyra\u017cenia generatorowe - generator expressions Co do zapisu: nie r\u00f3\u017cni\u0105 si\u0119 niczym od list comprehension , poza zmian\u0105 znak\u00f3w nawiasa z [] na () : list_comp = [ x ** 0.5 for x in range ( 1 , 11 )] gen_expr = ( x ** 0.5 for x in range ( 1 , 11 )) R\u00f3\u017cnica polega na tym, \u017ce list comprehension tworzy list\u0119, a wi\u0119c zajmuje miejsce w pami\u0119ci i czas procesora. Wyra\u017cenie generatorowe jest dopiero obliczane przy przechodzeniu przez nie, np. w formie p\u0119tli for : gen_expr = ( x ** 0.5 for x in range ( 1 , 10000001 )) # gen_expr nie obliczy\u0142o jeszcze tych 10 milion\u00f3w pierwiastk\u00f3w for x in gen_expr : # teraz ju\u017c kolejne elementy wyra\u017cenia generatorowego s\u0105 obliczane print ( x )","title":"Programowanie funkcyjne"},{"location":"programowanie_funkcyjne.html#funkcje-anonimowe-lambda","text":"Python umo\u017cliwia tworzenie funkcji w miejscu, bez osobnego deklarowania ich. Takie funkcje nazywane s\u0105 \"anonimowe\", bo nie musz\u0105 przyjmowa\u0107 nazw, a wykorzystuje si\u0119 je cz\u0119sto jako np. argumenty do \"normalnych\" funkcji. Podstawowa sk\u0142adania funkcji anonimowej jest nast\u0119puj\u0105ca: lambda arg1, arg2: arg1 ** arg2 \\--------/ \\----------/ argumenty operacja, kt\u00f3rej wynik jest zwracany przez funkcj\u0119 Podobie\u0144stwo do Excela Operacja funkcji lambda jest niemal identyczna jak zawarto\u015b\u0107 funkcji w kom\u00f3rce w Excelu. R\u00f3\u017cnic\u0105 jest jedynie odwo\u0142ywanie do zmiennych (Python) i nazw kom\u00f3rek (Excel). Przyk\u0142ad funkcji anonimowej obliczaj\u0105cej przeciwprostok\u0105tn\u0105 w tr\u00f3jk\u0105cie prostok\u0105tnym (twierdzenie Pitagorasa): lambda a , b : (( a * a ) + ( b * b )) ** 0.5 Przypomnienie Twierdzenie Pitagorasa: c*c = a*a + b*b . Operator ** to podnoszenie do pot\u0119gi. Je\u015bli wyk\u0142adnik pot\u0119gi ma posta\u0107 1/n (w powy\u017cszym przyk\u0142adzie: 1/2 ), to takie pot\u0119gowanie zamienia si\u0119 w pierwiastkowanie o stopniu n . Funkcje anonimowe s\u0105 obiektami w Pythonie i dzi\u0119ki temu mo\u017cemy je przypisa\u0107 w taki sam spos\u00f3b, jak przypisanie warto\u015bci do zmiennej: pitagoras = lambda a , b : (( a * a ) + ( b * b )) ** 0.5 Pozwala to w dalszym kodzie np. wywo\u0142ywa\u0107 tak\u0105 funkcj\u0119 anonimow\u0105 po jej, de facto, nazwie: >>> pitagoras = lambda a , b : (( a * a ) + ( b * b )) ** 0.5 >>> pitagoras ( 3 , 4 ) 5.0 Zadanie 1 Napisz funkcj\u0119 anonimow\u0105 obliczaj\u0105c\u0105 kwadrat danej warto\u015bci. Czy potrafisz wyt\u0142umaczy\u0107 czym si\u0119 to r\u00f3\u017cni od wykorzystania funkcji pow(a, b) lub operatora a ** b ? Zadanie 2 Napisz funkcj\u0119 anonimow\u0105 obliczaj\u0105c\u0105 \u015bredni\u0105 arytmetyczn\u0105 dw\u00f3ch warto\u015bci. Zadanie 3 Napisz funkcj\u0119 anonimow\u0105 sprawdzaj\u0105c\u0105 czy dana warto\u015b\u0107 jest wi\u0119ksza (lub mniejsza) od pewnej warto\u015bci. Taka funkcja anonimowa powinna zwraca\u0107 warto\u015b\u0107 logiczn\u0105.","title":"Funkcje anonimowe (lambda)"},{"location":"programowanie_funkcyjne.html#filtrowanie-aplikowanie-redukowanie","text":"W Pythonie istnieje kilka przydatnych funkcji wykorzystuj\u0105cych funkcje anonimowe i pracuj\u0105cych na zbiorach danych: filter(funkcja, iterator) : zwraca tylko te warto\u015bci ze zbioru danych, dla kt\u00f3rych funkcja(warto\u015b\u0107) zwr\u00f3ci\u0142a True . map(funkcja, iterator) : aplikuje funkcj\u0119 dla ka\u017cdej warto\u015bci. reduce(funkcja, iterator) : s\u0142u\u017cy do zredukowania ca\u0142ego zbioru danych do jednej warto\u015bci.","title":"Filtrowanie, aplikowanie, redukowanie"},{"location":"programowanie_funkcyjne.html#filtrowanie","text":"Dla przyk\u0142ad\u00f3w u\u017cyj\u0119 prostego zbioru danych temperatury: >>> temperatury = [ 37.6, 35.8, 37.6, 33.4, 34.1, 37.1, 35.9, 34.1, 37.1, 40.5, 38.5, 37.6, 35.8, 34.5, 36.4, 38.3, 37.5, 37.7, 34.0, 35.3, 35.7, 38.9, 34.8, 34.1, 39.6, 35.4, 34.7, 37.6, 38.4, 36.4, 39.8, 39.1, 37.1, 35.6, 36.8, 37.6, 36.7, 40.0, 38.0, 34.1, 35.5, 38.5, 36.1, 32.6, 32.9, 34.5, 41.0, 38.3, 33.7, 38.7, 36.9, 36.2, 33.7, 38.3, 35.3, 38.3, 40.1, 39.3, 38.2, 37.6, 39.1, 37.1, 34.4, 38.7, 35.8, 38.2, 38.2, 33.1, 37.8, 36.5, 37.6, 37.4, 34.3, 37.7, 36.0, 37.5, 37.6, 36.5, 31.3, 37.7, 40.3, 39.5, 35.7, 38.1, 34.7, 36.5, 34.3, 38.0, 37.0, 38.5, 39.4, 37.6, 41.7, 40.0, 38.4, 38.9, 34.2, 40.2, 34.3, 35.3 ] U\u017cyjmy teraz funkcji filtruj\u0105cej, \u017ceby znale\u017a\u0107 wszystkie warto\u015bci wi\u0119ksze lub r\u00f3wne 40.0 : >>> list ( filter ( lambda x : x >= 40.0 , temperatury )) [40.5, 40.0, 41.0, 40.1, 40.3, 41.7, 40.0, 40.2] Zadanie 4 Znajd\u017a wszystkie warto\u015bci mniejsze od 36.6 . Zadanie 5 Odfiltruj wszystkie warto\u015bci, kt\u00f3re s\u0105 mniejsze b\u0105d\u017a r\u00f3wne 35 lub wi\u0119ksze b\u0105d\u017a r\u00f3wne 40.","title":"Filtrowanie"},{"location":"programowanie_funkcyjne.html#aplikowanie","text":"Zacznijmy od znalezienia \u015bredniej warto\u015bci temperatury: >>> from statistics import mean >>> sr_temp = mean ( temperatury ) >>> sr_temp 36.9 Teraz mo\u017cna \u0142atwo obliczy\u0107 warto\u015bci odchylenia od \u015bredniej zbioru - przydatne w statystyce: >>> list ( map ( lambda x : x - sr_temp , temperatury )) [0.7, -1.1, 0.7, -3.5, -2.8, 0.2, -1.0, -2.8, 0.2, 3.6, 1.6, 0.7, -1.1, -2.4, -0.5, 1.4, 0.6, 0.8, -2.9, -1.6, -1.2, 2.0, -2.1, -2.8, 2.7, -1.5, -2.2, 0.7, 1.5, -0.5, 2.9, 2.2, 0.2, -1.3, -0.1, 0.7, -0.2, 3.1, 1.1, -2.8, -1.4, 1.6, -0.8, -4.3, -4.0, -2.4, 4.1, 1.4, -3.2, 1.8, 0.0, -0.7, -3.2, 1.4, -1.6, 1.4, 3.2, 2.4, 1.3, 0.7, 2.2, 0.2, -2.5, 1.8, -1.1, 1.3, 1.3, -3.8, 0.9, -0.4, 0.7, 0.5, -2.6, 0.8, -0.9, 0.6, 0.7, -0.4, -5.6, 0.8, 3.4, 2.6, -1.2, 1.2, -2.2, -0.4, -2.6, 1.1, 0.1, 1.6, 2.5, 0.7, 4.8, 3.1, 1.5, 2.0, -2.7, 3.3, -2.6, -1.6] Format liczb zmiennoprzecinkowych Podczas test\u00f3w powy\u017cszego kodu, Python potrafi\u0142 zamiast warto\u015bci 0.7 zwr\u00f3ci\u0107 0.7000000000000028 , dlatego dla uproszczonego zapisu wszystkie warto\u015bci zosta\u0142y zaokr\u0105glone do jednego miejsca po przecinku. Zadanie 6 Oblicz dla ka\u017cdej liczby w zbiorze temperatur kwadrat r\u00f3\u017cnicy tej liczby i \u015bredniej arytmetycznej ca\u0142ego zbioru.","title":"Aplikowanie"},{"location":"programowanie_funkcyjne.html#redukowanie","text":"Funkcja reduce z modu\u0142u functools pomaga w iteratywnym redukowaniu zbioru warto\u015bci do jednej warto\u015bci. \u017beby to lepiej zobrazowa\u0107, poka\u017c\u0119 dwa przyk\u0142ady u\u017cycia reduce do obliczenia sumy warto\u015bci i ich iloczynu. Przyk\u0142ad 1: obliczenie sumy >>> from functools import reduce >>> reduce ( lambda a , b : a + b , [ 1 , 2 , 3 , 4 , 5 ]) 15 Wykorzystanie funkcji reduce w powy\u017cszym przyk\u0142adzie sprowadza si\u0119 tak naprawd\u0119 do: ((((1 + 2) + 3) + 4) + 5) Przyk\u0142ad 2: obliczenie iloczynu >>> reduce ( lambda a , b : a * b , [ 1 , 2 , 3 , 4 ]) 24 Sprowadza si\u0119 to do: (((1 * 2) * 3) * 4) . Zadanie 7 Maj\u0105c obliczone warto\u015bci odchyle\u0144 temperatur od \u015bredniej temperatury, oblicz wariancj\u0119 tych warto\u015bci. Nie zapomnij o podzieleniu przez ilo\u015b\u0107 element\u00f3w w zbiorze!","title":"Redukowanie"},{"location":"programowanie_funkcyjne.html#tworzenie-zbiorow-danych-w-locie","text":"","title":"Tworzenie zbior\u00f3w danych w locie"},{"location":"programowanie_funkcyjne.html#tworzenie-list-list-comprehension","text":"Dzi\u0119ki generowaniu list w locie mo\u017cemy nawet do\u015b\u0107 skomplikowane p\u0119tle zamieni\u0107 na pojedyncze linijki kodu. Przyk\u0142adowo 4 linijki kodu generuj\u0105ce list\u0119 sze\u015bcian\u00f3w. szesciany = [] for x in range ( 10 ): szesciany . append ( x ** 3 ) W podstawowej wersji mo\u017cemy \"przenie\u015b\u0107\" p\u0119tl\u0119 do nawias\u00f3w kwadratowych: szesciany = [ x ** 3 for x in range ( 10 )] Og\u00f3lniejsza posta\u0107 list comprehension : nowa_lista = [ funkcja ( element ) for element in lista if warunek ( element )] Na przyk\u0142ad by przygotowa\u0107 list\u0119 kwadrat\u00f3w liczb nieparzystych z zakresu od 1 do 100: kwadraty = [ el ** 2 for el in range ( 1 , 101 ) if el % 2 == 0 ] Zadanie 1 Napisz pogram, kt\u00f3ry policzy kwadraty liczb z zakresu [1,10000], kt\u00f3re podzielne s\u0105 przez 5 lub 9. Nast\u0119pnie sprawd\u017a, kt\u00f3re z uzyskanych liczb s\u0105 podzielne zar\u00f3wno przez 5 jak i przez 9.","title":"Tworzenie list - list comprehension"},{"location":"programowanie_funkcyjne.html#tworzenie-zbiorow","text":"W podobny spos\u00f3b mo\u017cna te\u017c przygotowa\u0107 zbi\u00f3r. zbior = { znak for znak in \"abracadabra\" if znak not in \"abc\" } Zadanie 2 Stw\u00f3rz zbi\u00f3r, kt\u00f3ry wype\u0142nisz 30 wywo\u0142aniami funkcji random.randint(1, 30) . Ile razy wylosowana zosta\u0142a ta sama warto\u015b\u0107? (Sprawdzisz to por\u00f3wnuj\u0105c ilo\u015b\u0107 element\u00f3w zbioru). Jak si\u0119 zachowa program, je\u015bli zmienisz argumenty do funkcji randint ? A je\u015bli zmienisz ilo\u015b\u0107 wywo\u0142a\u0144 tej funkcji?","title":"Tworzenie zbior\u00f3w"},{"location":"programowanie_funkcyjne.html#tworzenie-sownikow","text":"Podobnie mo\u017cna stworzy\u0107 s\u0142ownik: tekst = \"abracadabra\" wystapienia = { znak : tekst . count ( znak ) for znak in tekst }","title":"Tworzenie s\u0142ownik\u00f3w"},{"location":"programowanie_funkcyjne.html#wyrazenia-generatorowe-generator-expressions","text":"Co do zapisu: nie r\u00f3\u017cni\u0105 si\u0119 niczym od list comprehension , poza zmian\u0105 znak\u00f3w nawiasa z [] na () : list_comp = [ x ** 0.5 for x in range ( 1 , 11 )] gen_expr = ( x ** 0.5 for x in range ( 1 , 11 )) R\u00f3\u017cnica polega na tym, \u017ce list comprehension tworzy list\u0119, a wi\u0119c zajmuje miejsce w pami\u0119ci i czas procesora. Wyra\u017cenie generatorowe jest dopiero obliczane przy przechodzeniu przez nie, np. w formie p\u0119tli for : gen_expr = ( x ** 0.5 for x in range ( 1 , 10000001 )) # gen_expr nie obliczy\u0142o jeszcze tych 10 milion\u00f3w pierwiastk\u00f3w for x in gen_expr : # teraz ju\u017c kolejne elementy wyra\u017cenia generatorowego s\u0105 obliczane print ( x )","title":"Wyra\u017cenia generatorowe - generator expressions"},{"location":"serializacja.html","text":"Serializacja i trwa\u0142o\u015b\u0107 obiekt\u00f3w Modu\u0142 pickle Serializacja i trwa\u0142o\u015b\u0107 obiekt\u00f3w mo\u017ce zosta\u0107 zrealizowana przy pomocy wbudowanych narz\u0119dzi Pythona. Modu\u0142 pickle serializuje obiekty do i z plik\u00f3w. import pickle p = pickle . Pickler ( file ) # file to otwarty obiekt pliku p . dump ( obj ) # Zrzut obiektu Aby odserializowa\u0107 obiekt, u\u017cywamy funkcji unpickle. p = pickle . Unpickler ( file ) # file to otwarty obiekt pliku obj = p . load () # \u0141adowanie obiektu Serializacja - wskaz\u00f3wki Wi\u0119kszo\u015b\u0107 typ\u00f3w wbudowanych mo\u017cna podda\u0107 serializacji. Mo\u017cna dokona\u0107 serializacji obiektu klasy. Klasa musi by\u0107 dost\u0119pna w momencie odtwarzania obiektu. Sam kod klasy nie jest serializowany. Python automatycznie importuje modu\u0142 zawieraj\u0105cy odtwarzan\u0105 klas\u0119. Pewne typy obiekt\u00f3w nie mog\u0105 by\u0107 serializowane np. sockety, pliki. Dowolny obiekt zapewniaj\u0105cy metody write(), read() i readline() mo\u017ce by\u0107 u\u017cywany jako plik. Obiekty rekursywne mo\u017cna podda\u0107 serializacji. Dane po serializacji mo\u017cna przenosi\u0107 mi\u0119dzy r\u00f3\u017cnymi systemami operacyjnymi i architekturami sprz\u0119towymi. Serializacja obiekt\u00f3w zastosowana w Pythonie nie jest dost\u0119pna z poziomu program\u00f3w napisanych w innych j\u0119zykach programowania. Modu\u0142 shelve Modu\u0142 shelve umo\u017cliwia prosty zapis serializowanych danych do pliku z wykorzystaniem sk\u0142adni s\u0142ownika. Klucze musz\u0105 by\u0107 ci\u0105gami znak\u00f3w. Warto\u015bciami mog\u0105 by\u0107 dowolne obiekty Pythona dla kt\u00f3rych dzia\u0142a modu\u0142 pickle . import shelve d = shelve . open ( \"data\" ) d [ 'foo' ] = 42 # Zapis danych do pliku x = d [ 'bar' ] # Odczyt danych z pliku","title":"Serializacja"},{"location":"serializacja.html#serializacja-i-trwaosc-obiektow","text":"","title":"Serializacja i trwa\u0142o\u015b\u0107 obiekt\u00f3w"},{"location":"serializacja.html#modu-pickle","text":"Serializacja i trwa\u0142o\u015b\u0107 obiekt\u00f3w mo\u017ce zosta\u0107 zrealizowana przy pomocy wbudowanych narz\u0119dzi Pythona. Modu\u0142 pickle serializuje obiekty do i z plik\u00f3w. import pickle p = pickle . Pickler ( file ) # file to otwarty obiekt pliku p . dump ( obj ) # Zrzut obiektu Aby odserializowa\u0107 obiekt, u\u017cywamy funkcji unpickle. p = pickle . Unpickler ( file ) # file to otwarty obiekt pliku obj = p . load () # \u0141adowanie obiektu","title":"Modu\u0142 pickle"},{"location":"serializacja.html#serializacja-wskazowki","text":"Wi\u0119kszo\u015b\u0107 typ\u00f3w wbudowanych mo\u017cna podda\u0107 serializacji. Mo\u017cna dokona\u0107 serializacji obiektu klasy. Klasa musi by\u0107 dost\u0119pna w momencie odtwarzania obiektu. Sam kod klasy nie jest serializowany. Python automatycznie importuje modu\u0142 zawieraj\u0105cy odtwarzan\u0105 klas\u0119. Pewne typy obiekt\u00f3w nie mog\u0105 by\u0107 serializowane np. sockety, pliki. Dowolny obiekt zapewniaj\u0105cy metody write(), read() i readline() mo\u017ce by\u0107 u\u017cywany jako plik. Obiekty rekursywne mo\u017cna podda\u0107 serializacji. Dane po serializacji mo\u017cna przenosi\u0107 mi\u0119dzy r\u00f3\u017cnymi systemami operacyjnymi i architekturami sprz\u0119towymi. Serializacja obiekt\u00f3w zastosowana w Pythonie nie jest dost\u0119pna z poziomu program\u00f3w napisanych w innych j\u0119zykach programowania.","title":"Serializacja - wskaz\u00f3wki"},{"location":"serializacja.html#modu-shelve","text":"Modu\u0142 shelve umo\u017cliwia prosty zapis serializowanych danych do pliku z wykorzystaniem sk\u0142adni s\u0142ownika. Klucze musz\u0105 by\u0107 ci\u0105gami znak\u00f3w. Warto\u015bciami mog\u0105 by\u0107 dowolne obiekty Pythona dla kt\u00f3rych dzia\u0142a modu\u0142 pickle . import shelve d = shelve . open ( \"data\" ) d [ 'foo' ] = 42 # Zapis danych do pliku x = d [ 'bar' ] # Odczyt danych z pliku","title":"Modu\u0142 shelve"}]}